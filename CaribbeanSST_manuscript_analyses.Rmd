---
title: '**Caribbean Sea Surface Temperature Analysis**'
author: "Colleen Bove"
output:
  html_document:
    theme: simplex
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r knit options, include=FALSE}

knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE)

```

```{r load libraries}

### Used packages that need to be installed to run code:
# install.packages("sf", "ncdf4", "raster", "ggrepel", "maptools", "rgdal", "ggplot2", "tidyverse", "xts", "RColorBrewer", "tidyr", "dplyr", "fields", "gganimate", "sp", "plotly", "grDevices", "repmis", "binr", "cowplot", "viridis", "rnaturalearth", "rnaturalearthdata")

# library(devtools)
# devtools::install_github("NCAR/fields")
# devtools::install_github("thomasp85/transformr") # need this for the GIFs of figures
# devtools::install_github("paleolimbot/ggspatial")

library(sf)
library(ncdf4)
library(ggrepel)
library(raster) 
library(viridis)
library(maptools)
library(rgdal)
library(ggplot2)
library(cowplot)
library(tidyverse)
library(rnaturalearth)
library(xts)
library(RColorBrewer)
library(tidyr)
library(dplyr)
library(binr)
library(fields)
library(gganimate)
library(sp)
library(plotly)
library(grDevices)
library(repmis)

```

```{r other setup}

## set the current date
date <- Sys.Date() 


## spatial subsetting for Caribbean region
Xmin<- -100
Xmax<- -55
Ymin<- 0
Ymax<- 40


## set the projection
proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84"


## set the binning of p-values for plotting
bins <- c(-Inf, 0.0001, 0.001, 0.01, 0.05, 0.1, Inf)
bin_names <- c("< 0.0001", "0.0001 - 0.001", "0.001 - 0.01", "0.01 - 0.05", "0.05 - 0.1", "> 0.1")


## Create base map for SST maps
map_base <- ggplot2::fortify(maps::map(fill = TRUE, plot = FALSE)) %>% 
  dplyr::rename(lon = long)


## Make a shapefile of lat/lon bounds of MHW map
# make dataframe of lat/lon
bound_df <- data.frame("lon" = c(262.125, 285.125, 285.125, 302.125, 302.125, 285.125, 285.125, 276.125, 276.125, 271.125, 269.625, 262.125,262.125),
                       "lat" = c(31, 31, 25.125, 25.125, 9.125, 9.125, 7.375, 7.375, 15.875, 15.875, 17.875, 17.875, 31))
bound_df$lon <- bound_df$lon - 360 # convert lon back into -180 to 180
bound_matrix <- data.matrix(bound_df) # Transform from dataframe to a matrix
bound_poly <- Polygon(bound_matrix) # transform matrix to polygon
bound_SP <- SpatialPolygons(list(Polygons(list(bound_poly), ID = "a")), proj4string=CRS(proj)) # convert polygon to SpatialPolygon object
bound_SP_df <- as(bound_SP, "SpatialPolygonsDataFrame") # convert to SpatialPolygonsDataFrame

```


*All code, data, and other necessary files needed to reproduce these analyses and figures can be found on my [CaribbeanSST GitHub repository](https://github.com/seabove7/CaribbeanSST). Dropbox links are also provided for large files (netCDF/shape) for download within the Rmarkdown code*   

```{r setting non-git file paths}

### Since the shape and netCDF files are too large to store on GitHub, those need to be stored locally.
## Dropbox links are included to download the corresponding files. Just update the local path to each.
## The paths for the files stored on Dropbox are below:

## gshhs_f.b: coastline map shapefile
# Dropbox link: https://www.dropbox.com/s/exn3p4v2q6isvla/gshhs_f.b?dl=0
gshhs_f_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/gshhs_f.b"

## WCMC008_CoralReef2018_Py_v4.shp: global coral reef shapefiles
# Dropbox link: https://www.dropbox.com/sh/q9yn83jzx57yx9h/AACHWXkNUQ7HX4ZKqnaMzv2aa?dl=0
WCMC008_CoralReef2018_Py_v4_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/14_001_WCMC008_CoralReefs2018_v4/01_Data/WCMC008_CoralReef2018_Py_v4.shp"

## meow_ecos.shp: global ecoregion shapefiles
# Web link: https://www.worldwildlife.org/publications/marine-ecoregions-of-the-world-a-bioregionalization-of-coastal-and-shelf-areas
ecoregion_shape_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/MEOW/meow_ecos.shp"

## HadISST_sst.nc: 
# Dropbox link: https://www.dropbox.com/s/o6filpg0b3xe5i5/HadISST_sst.nc?dl=0
HadISST_sst_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/HadISST_sst.nc"

## pathfinder_combined_monthly_data.nc: 
# Dropbox link: https://www.dropbox.com/s/x3m622sscegx9m7/pathfinder_combined_monthly_data.nc?dl=0
pathfinder_combined_monthly_data_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/pathfinder_combined_monthly_data.nc"

## Pathfinder_monthly_edit.nc: 
# Dropbox link: https://www.dropbox.com/s/mvh9atmfuqhdq3k/Pathfinder_monthly_edit.nc?dl=0
Pathfinder_monthly_edit_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/PathfinderSST_UPDATE_monthly_edit.nc"

```


```{r read in land shapefile, include=FALSE}

if (!rgeosStatus()) gpclibPermit()
gshhs.f.b <- gshhs_f_path
land <- getRgshhsMap(gshhs.f.b, xlim = c(-105, -40), ylim = c(-10, 40)) %>%
  fortify()

```

```{r create Caribbean reef shapefile, eval=FALSE, include=FALSE}

# read in the global coral reef shapefile 
shape <- shapefile(WCMC008_CoralReef2018_Py_v4_path)
reefs_cropped <- crop(shape, extent(Xmin, Xmax, Ymin, Ymax)) # crop for the Caribbean region only
shapefile(reefs_cropped, "data/ReefData/Caribbean_reefs.shp") # save the new Caribbean-specific reef shapefile

```

```{r reef shape to df, include=FALSE}

reefs <- st_read("data/ReefData/Caribbean_reefs.shp") # for plotting reefs
#reefs <- reefs[1,] # to play with a more manageable file 
reef_pt <- st_coordinates(reefs) # extracts all the polygon coordinates into a matrix
reef_pt <- as.data.frame(reef_pt) # convert from matrix to dataframe

# identify reef shape files containing reef polygons for extracting data
shapes <- readOGR('data/ReefData', 'Caribbean_reefs') # for extracting data

```

```{r plot caribbean region and reefs}

ggplot() + 
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  #geom_rect(aes(xmin=-Inf,xmax=Inf,ymin=-Inf, ymax=41.5), fill="lightblue2") +
  geom_polygon(data = land, aes(x=long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  #geom_sf(data = reefs, colour = "red") +
  geom_point(data = reef_pt, aes( x = X, y = Y), colour = "black", size = 0.1) +
  coord_sf(xlim = c(-95,-55), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggsave("figures/Fig1_CaribbeanReefs_map.pdf", width = 8, height = 5)

```

**Figure 1 |** Map of reefs included in SST analyses specific to reef locations. Reef shape files were obtained from the [UN Environment World Conservation Monitoring Centre](http:/data.unep-wcmc.org/datasets/1). Coral reef shapefiles were downloaded 30 June 2020.

<br/>

## <span style="color: #313695;">SST trends at reef locations</span>{.tabset}

#### SST data extraction

847 reef shape files were obtained from the [UN Environment World Conservation Monitoring Centre](http:/data.unep-wcmc.org/datasets/1) database (**Figure 1**) and used to extract SST from both the HadISST and Pathfinder datasets. Each reef polygon was used to extract the weighted mean SST per raster layer (i.e., monthly layers in HadISST or daily in Pathfinder). Several reef polygons could not be used to extract SST as polygons, so the GPS coordinates that made up the points of the polygons were used to extract SST that corresponded to that point. Those SSTs were then averaged across each polygon to result in a single SST mean for the polygon. Thus, each of the 847 reef polygons were assigned a mean SST per sampling frequency of each SST dataset.


A custom cluster was created to extract SST data on a loop from HadISST and Pathfinder raster layers corresponding to each reef polygon. A cluster was used to run the loop in parallel because of the significant time it would take looping through the data one layer at a time. However, for smaller dataset, a simple forloop will also accomplish the same goal (both methods are included in the code). 

<br/>


### HadISST dataset (1870 - 2019)

HadISST reports monthly SSTs at 1$^\circ$ resolution. [Data can be accessed here](https://www.metoffice.gov.uk/hadobs/hadisst/). According to their website:

> "The SST data are taken from the Met Office Marine Data Bank (MDB), which from 1982 onwards also includes data received through the Global Telecommunications System (GTS). In order to enhance data coverage, monthly median SSTs for 1871-1995 from the Comprehensive Ocean-Atmosphere Data Set (COADS) (now ICOADS) were also used where there were no MDB data. The sea ice data are taken from a variety of sources including digitized sea ice charts and passive microwave retrievals."

```{r HadISST raster}

## read in the HadISST raster
had_data <- HadISST_sst_path
data_brick <- brick(had_data) # read SST data as rasterbrick
data_brick <- crop(data_brick, extent(Xmin, Xmax, Ymin, Ymax)) # clip rasterbrick for Caribbean region only (see 'spatial subsetting' above)


ncdf_file <- nc_open(had_data)

nc_lats <- ncdf_file$dim$latitude$vals #other way of looking into the data structure; extracting lats (HadISST)
nc_longs <- ncdf_file$dim$lon$vals #longs here (HadISST)
nc_longs[nc_longs>180] <- nc_longs[nc_longs>180]-360

#time handling
raw_times <- ncdf_file$dim$time$vals #times are seconds after the "start of time"
startoftime <- substr(ncdf_file$dim$time$units,1,19) #HadISST
nc_times <- as.POSIXct(gsub("days since ","",startoftime), tz="UTC", format='%Y-%m-%d')+(raw_times*60*60*24) #HadISST
nc_times <- nc_times+3600*3 #to center readings at noon - just cosmetics
nc_close(ncdf_file) #close the file

#temporal subsetting  
start_date <- "1870/01/01"
end_date <- "2019/12/31"
start_date <- as.POSIXct(start_date,tz="UTC")
end_date <- as.POSIXct(end_date,tz="UTC")

#restrict temporally
Tstart_index <- min(which(difftime(nc_times,start_date)>0))
Tend_index <- min(which(difftime(nc_times,end_date)>0))
data_brick <- data_brick[[Tstart_index:Tend_index]]
time <- nc_times[Tstart_index:Tend_index]

save(time, nc_times, file = "data/HadISST/HadISST_times.Rdata") # save the time variables for IDs for running scripts remotely


### subsetting the HadISST raster for 1981 - 2019 timespand for comparison with Pathfinder
start_dateb <- "1981-08-16"
start_dateb <- as.POSIXct(start_dateb, tz="UTC")

Tstart_indexb <- min(which(difftime(nc_times, start_dateb)>0))
data_brickb <- data_brick[[Tstart_indexb:Tend_index]]
timeb <- nc_times[Tstart_indexb:Tend_index]

```

```{r HadISST lm map df creation}

## simple lm function applied to the full HadISST raster brick
lm.fun <- function(x, time)
{
  if(any(is.na(x))){NA}
  else{
    lm(x~time)$coefficients[2]*60*60*24 # slope here is degrees/day
  }
}
raster_slope <- calc(data_brick, function(x)lm.fun(x, time = time))

# convert the raster to a df for plotting
raster_slope <- raster_slope*(365.25*10) # this is currently C per decade
had_slope <- as.data.frame(as(raster_slope, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_slope) <- c("sst", "x", "y")


########## Same idea, this time only being used on the 1981 - 2019 subset

## simple lm function applied to the raster brick
lm.funb <- function(x, timeb)
{
  if(any(is.na(x))){NA}
  else{
    lm(x~timeb)$coefficients[2]*60*60*24 # slope here is degrees/day
  }
}
raster_slopeb <- calc(data_brickb, function(x)lm.funb(x, timeb = timeb))

# convert the raster to a df for plotting
raster_slope_sub <- raster_slopeb*(365.25*10) # this is currently C per decade
had_slope_sub <- as.data.frame(as(raster_slope_sub, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_slope_sub) <- c("sst", "x", "y")

# --------- *Plotting occurs down at the bottom of the markdown file* --------- #

```

```{r HadISST pvalue map df creation}

## function to pull the p value per pixel of the simple lm applied to the full HadISST raster brick 
pval.fun <- function(x, time)
{
  if(any(is.na(x))){NA}
  else{
    summary(lm(x ~ time))$coefficients[4] # pulls the p value
  }
}
raster_pval <- calc(data_brick, function(x)pval.fun(x, time = time))

# convert the raster to a df for plotting
had_pavl <- as.data.frame(as(raster_pval, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_pavl) <- c("pval", "x", "y")
had_pavl$bins <- cut(had_pavl$pval, breaks = bins, labels = bin_names) # bins the pvales into 6 unique bins for plotting


########## Same idea, this time only being used on the 1981 - 2019 subset

## function to pull the p value per pixel of the simple lm applied to the raster brick 
pval.funb <- function(x, timeb)
{
  if(any(is.na(x))){NA}
  else{
    summary(lm(x~timeb))$coefficients[4] # pulls the p value
  }
}
raster_pvalb <- calc(data_brickb, function(x)pval.funb(x, timeb = timeb))

# convert the raster to a df for plotting
had_pval_sub <- as.data.frame(as(raster_pvalb, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_pval_sub) <- c("pval", "x", "y")
had_pval_sub$bins <- cut(had_pval_sub$pval, breaks = bins, labels = bin_names) # bins the pvales into 6 unique bins for plotting

# --------- *Plotting occurs down at the bottom of the markdown file* --------- #

```

```{r NOT RUN - HadISST SST polygon extraction - REMOTE, eval=FALSE, include=FALSE, paged.print=FALSE}

# ***NOTE***
####--- this portion of the script was run on a high performance computing cluster because of the long runtime needed
####--- see separate R script (SSTExtraction_ReefPolygon.R) for instructions (located in the code folder)
####--- the script can be put on a cluster with the HadISST netCDF (HadISST_sst.nc) to run


##########################################
# If working with a smaller data set, you can run the below code to accomplish the same outcome as the SSTExtraction_ReefPolygon.R script.
# The code below has been adapted to specifically work with the HadISST_sst.nc and Caribbean_reefs.shp files:

## Load the Pathfinder EDIT netCDF as rasterBrick
had_brick <- brick(HadISST_sst_path)

## Create an empty dataframe to populate while running the forloop with the following parameters:
had_df <- data.frame('date' = integer(),
                      'mean' = integer(),
                      'min' = integer(),
                      'max' = integer(),
                      'weighted' = integer(),
                      'difference' = integer(),
                      'polygon' = integer())


## for loop that runs through each raster layer and extracts the SST corresponding to reef polygons
for (i in 1:had_brick@file@nbands) {
  raster <- had_brick[[i]]
  
  mean_sst_vals <- raster::extract(raster, shapes, fun=mean) # calculates a mean SST within each reef polygon
  min_sst_vals <- raster::extract(raster, shapes, fun=min) # minimum SST within each reef polygon
  max_sst_vals <- raster::extract(raster, shapes, fun=max) # maximum SST within each reef polygon
  weighted_mean <- raster::extract(raster, shapes, weights=TRUE, fun=mean) # calculates the weighted mean SST within each reef polygon
  
  df <- data.frame('date' = raster@data@names,
                   'mean' = mean_sst_vals,
                   'min' = min_sst_vals,
                   'max' = max_sst_vals,
                   'weighted' = weighted_mean,
                   'difference' = mean_sst_vals - weighted_mean)
  
  df$polygon <- rownames(df) # names the row with polygon ID (numeric IDs)
  
  had_df <- rbind(had_df, df) # adds the above information for each polygon onto the dataframe containing the other calculated values
}


## Once completed, saves the resulting dataframe as both a .Rdata object and .csv
## *** Only uncomment these lines if you want to write over existing files ***
#save(had_df, file = "HadISST_reefs_poly.Rdata")
#write.csv(had_df, file = "HadISST_reefs_poly.csv")

```

```{r NOT RUN - had GPS extraction, eval=FALSE, include=FALSE}

## this is the data frame of extracted SST based on polygons
load("data/HadISST/HadISST_reefs_poly.Rdata")
had_poly <- had_df[,c(1,7,5)] # select only the polygon ID, weighted mean SST, and time 
had_poly$polygon <- factor(had_poly$polygon)
had_poly <- spread(had_poly, polygon, weighted) # convert from long to wide format

## create dataframe of missing polygon GPS corrdinates to extract from HadISST raster
NAcol <- colnames(had_poly)[colSums(is.na(had_poly)) > 0] # identify the columns with NA values to pull SST from GPS points instead of polygons
reef_gps <- reef_pt %>% filter(L3 == NAcol) # select only GPS points of polygons missing SST data above

## converting sampling points to spatial points and applying projection to points
LongLat <- cbind(reef_gps$X, reef_gps$Y) 
ReefPTS <- SpatialPoints(LongLat)
proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84"
projection(ReefPTS) <- proj


#some pixels fall on land. Finding nearest valid pixels
#pixels coordinates
first_day <- data_brick[[1]]
pixel_coordinates <- coordinates(first_day)
#delete coordinates where data is missing (NA)
#first, extract data for all pixels
data <- raster::extract(first_day, pixel_coordinates)
#now check which ones are NA and delete those entries from the "pixel.coordinates" list
pixel_coordinates <- pixel_coordinates[!is.na(data),]


#create new sampling points, shifted to the center of the pixel they fall on, or to the near pixel in case that one is NA
ReefPTS_shifted <- vector()
#loop cycling through sampling points
for (p in 1:length(ReefPTS)) {
  #geodesic distances
  distances <- rdist.earth(coordinates(ReefPTS[p]),pixel_coordinates,miles=FALSE)
  #coordinates of the pixel that is at shorter distance 
  shifted_coordinates <- pixel_coordinates[which.min(distances),]
  #assigning those coordinates to a new item
  cmd <- paste0("sp.",p,"<-shifted_coordinates")
  eval(parse(text=cmd))
  #points(pt[1],pt[2])
  cmd <- paste0("ReefPTS_shifted<-rbind(ReefPTS_shifted,sp.",p,")")
  eval(parse(text = cmd))
}



#extract data from the sst brick with the sampling points shifted
had_sst <- raster::extract(data_brick, ReefPTS_shifted)
#look at it lines are locations; columns are dates


#convert the data matrix to a xts object
had_sst_xts <- xts(t(had_sst), time) #t is used to transpose the matrix because xts assumes dates are along the lines, not columns
colnames(had_sst_xts) <- reef_gps$L3 #ID the columns

had_sst_df <- data.frame(date=index(t(had_sst_xts)), coredata(t(had_sst_xts)))
had_sst_df$polygon <- factor(reef_gps$L3) #ID the columns
had_sst_df$date <- NULL

had_sst_long <- gather(had_sst_df, date, sst, X1870.01.16.15.00.00:X2020.01.16.15.00.00)


had_gps <- aggregate(had_sst_long, by = list(had_sst_long$date, had_sst_long$polygon), FUN = mean)[,c(1:2,5)]
had_gps2 <- had_gps %>% separate(Group.1, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
had_gps2$date <- paste(had_gps2$year, had_gps2$month, had_gps2$day, sep = ".")

had_gps2 <- had_gps2[, c(7,9,8)]
had_gps2 <- spread(had_gps2, Group.2, sst)


had_poly <- select(had_poly, -c(NAcol)) # remove the NA columns before adding them back in below

had_full <- had_poly %>% 
  left_join(had_gps2, by = c("date" = "date"))

save(had_full, file = "data/HadISST/HadISST_reefs_gps.Rdata")

```

```{r UPDATED had GPS extraction, eval=FALSE, include=FALSE}

reef_gps <- read.csv("data/ReefData/CaribbeanReef_points.csv") # read in FULL reef locations csv

## convert sampling points to spatial points and applying projection to points
LongLat <- cbind(reef_gps$lon, reef_gps$lat) 
ReefPTS <- SpatialPoints(LongLat)
proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84"
projection(ReefPTS) <- proj

#  ## shift points (some pixels fall on land so finding nearest valid pixels
#  # pixels coordinates
#  first_day <- data_brick[[1]]
#  pixel_coordinates <- coordinates(first_day)
#  
#  # delete coordinates where data is missing (NA)
#  data <- raster::extract(first_day, pixel_coordinates) # extract data for all pixels
#  pixel_coordinates <- pixel_coordinates[!is.na(data),] # remove NA from the "pixel.coordinates" list
#  
#  # Create new sampling points, shifted to the center of the pixel they fall on, or to the near pixel in case that one is NA
#  ReefPTS_shifted <- vector()
#  #loop cycling through sampling points
#  for (p in 1:length(ReefPTS)) {
#    #geodesic distances
#    distances <- rdist.earth(coordinates(ReefPTS[p]),pixel_coordinates,miles=FALSE)
#    #coordinates of the pixel that is at shorter distance 
#    shifted_coordinates <- pixel_coordinates[which.min(distances),]
#    #assigning those coordinates to a new item
#    cmd <- paste0("sp.",p,"<-shifted_coordinates")
#    eval(parse(text=cmd))
#    #points(pt[1],pt[2])
#    cmd <- paste0("ReefPTS_shifted<-rbind(ReefPTS_shifted,sp.",p,")")
#    eval(parse(text = cmd))
#  }
#  

## extract data from the sst brick with the sampling points shifted
had_sst <- raster::extract(data_brick, ReefPTS)   # had_sst <- raster::extract(data_brick, ReefPTS_shifted)



## convert the data matrix to a final dataframe
had_sst_xts <- xts(t(had_sst), time) # t is used to transpose the matrix because xts assumes dates are along the lines, not columns
had_sst_df <- data.frame(date=index(t(had_sst_xts)), coredata(t(had_sst_xts))) # convert xts object to dataframe
had_sst_df$reef <- factor(seq(1, length(had_sst_df$date), 1)) # ID the columns to identify unique reefs
had_sst_df$date <- NULL # remove this column since it is repetitive 
had_sst_long <- gather(had_sst_df, date, sst, X1870.01.16.15.00.00:X2020.01.16.15.00.00) # convert from wide to long format

## update the dataframe for saving
had_gps <- had_sst_long %>% separate(date, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
had_gps$date <- paste(had_gps$year, had_gps$month, had_gps$day, sep = ".") # creates a full date column (XYear.Month.Day)
had_gps <- had_gps[, -c(2:7)] # remove columns for hour, minute, and seconds (we won't use these)
had_gps <- spread(had_gps, reef, sst)

## save the final dataframe (.csv or Rdata)
#write.csv(had_gps, file = "data/HadISST/HadISST_reefs_SST_update.csv") # to save file as .csv
save(had_gps, file = "data/HadISST/HadISST_reefs_SST_update2.Rdata") # to save file as Rdata (I saved as Rdata since it is large)

```


<br/>

```{r had monthly SST dataframe construction}

load("data/HadISST/HadISST_reefs_SST_update2.Rdata")

had_full <- had_gps # only need to use this to make the UPDATED reef SST dataframe compatible below

## create a new dataframe of simple stats per time
had_full2 <- data.frame("date" = had_full[,1],
                      "mean_temp" = rowMeans(had_full[,-1], na.rm = TRUE),
                      "max_temp" = apply(had_full[,-1], 1, FUN=max, na.rm = TRUE),
                      "min_temp" = apply(had_full[,-1], 1, FUN=min, na.rm = TRUE),
                      "n" = length(had_full[,-1]))

had_full2 <- had_full2 %>% separate(date, c("year", "month","day"), convert = TRUE) # create year, month, and day column columns
had_full2$year <- as.numeric(gsub("\\X", "", had_full2$year)) # convert the year column to numerics and remove 'X'
had_full2$month2 <- factor(had_full2$month) # make a month as a factor column for plotting

```

```{r had monthly SST per year, fig.align='center'}

#### Data visualization of monthly SST per year #### 

# calculate summary statistic per month across years
HADI_month_avg <- had_full2 %>% 
  group_by(month) %>% 
  summarize(mean = mean(mean_temp, na.rm = TRUE),
            sd = sd(mean_temp, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se)

# make year integer for better plotting
had_full2$year <- as.integer(had_full2$year)

## create plots of monthly HadISST per year
# markdown plot
hadplot_markdown <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 45, hjust = 1), text = element_text(size = 14)) +
  theme(legend.position = c(0.065, 0.85), legend.key.size = unit(0.3, "cm"), legend.background = element_rect(fill = NA), plot.title = element_text(size = 12)) + # legend theme
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  geom_line(data = had_full2[-151,], aes(x = month, y = mean_temp, group = year, colour = year), alpha = 0.6, size = 0.4) +
  scale_colour_gradient2("", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(had_full2$year), space="Lab", breaks = seq(1870, 2020, 50)) +
  #geom_ribbon(data = HADI_month_avg, aes(x = month, ymin = lowerci, ymax = upperci), colour = "black", alpha = 0.6, linetype = 2) + 
  #geom_line(data = HADI_month_avg, aes(x = month, y = mean), colour = "black", group = 1, size = 1.5) +
  scale_x_continuous(name = "Month", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  ylab('SST (°C)') +
  ggtitle("HadISST (1870 - 2019)") + 
  theme(plot.title = element_text(size = 13)) +
  ggsave("figures/Fig2_HadISST_SST_monthly.pdf", width = 6, height = 3.5)

ggplotly(hadplot_markdown) # this plots an interactive version of the map in the Rmarkdown HTML output

# create version of the plot for creating a GIF of HadISST data
had_plot_gif <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  geom_line(data = had_full2[-151,], aes(x = month, y = mean_temp, group = year, colour = year), size = 1) +
  scale_colour_gradient2("Year", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(had_full2$year), space="Lab") +
  #geom_ribbon(data = HADI_month_avg, aes(x = month, ymin = lowerci, ymax = upperci), colour = "black", alpha = 0.6, linetype = 2) + 
  #geom_line(data = HADI_month_avg, aes(x = month, y = mean), colour = "black", group = 1, size = 1.5) +
  scale_x_continuous(name = "Month", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  ylab('SST (°C)')


#### Summary information for 'Results' text:

## Monthly SST min/max/mean
had_mean<- had_full2 %>% 
  group_by(month) %>% 
  summarise("mean" = mean(mean_temp, na.rm = TRUE))

min(had_mean$mean)
max(had_mean$mean)
mean(had_mean$mean)

```

**Figure 2 |** Mean SST across coral reefs sites at each monthly sampling event (HadISST dataset) from 1870 to 2019. Year is represented by colour of each line, changing from <span style="color: #2166ac;">blue</span> to <span style="color: #d6604d;">red</span> in more recent years. Maximum SST generally occurs for the region between August and October and the minimum SST occurs between January and March.

```{r had GIF, include=FALSE}

## below is code to transform the HadISST monthly SST plot into a GIF (not shown in the Rmarkdown file, but saved in the figures folder)
# SST is plotted one year at a time in order in the GIF

had_gif <- had_plot_gif + 
  transition_time(year) +
  labs(title = "Year: {frame_time} (HadISST)") +
  shadow_mark(alpha = 0.1, size = 0.5)

animate(had_gif, fps = 10, nframes = 300, end_pause = 2, width = 325, height = 200)
anim_save("figures/HadISST.gif")

```


<br/>

```{r had annual SST}

## construct df for the GAM smoothing of mean SST
sst_gam_df <- gather(had_full, reef, sst, `1`:`5607`)
sst_gam_df$date <- gsub("\\X", "", sst_gam_df$date) # convert year to numeric and remove 'X'
sst_gam_df <- sst_gam_df %>% separate(date, c("year", "month","day"), convert = TRUE) # create year, month, and day column columns
sst_gam_df <- subset(sst_gam_df, year != "2020")


#### Data visualization per year across months #### 

# calculate summary statistic per month across years
HADI_year_avg <- had_full2 %>% 
  group_by(year) %>% 
  summarize(mean = mean(mean_temp, na.rm = TRUE),
            max = max(mean_temp, na.rm = TRUE),
            min = min(mean_temp, na.rm = TRUE),
            sd = sd(mean_temp, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se,
         range = max - min)


## plot with smoothed trend
HadISST_SST_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size = 14)) +
  #geom_vline(xintercept = 1981, colour = "lightgrey") +
  geom_hline(yintercept = mean(HADI_year_avg[-151,]$mean), colour = "grey", linetype = 2) +
  geom_ribbon(data = HADI_year_avg[-151,], aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.3, linetype = 1) + 
  #geom_line(data = HADI_year_avg[-151,], aes(x = year, y = mean), colour = "black", group = 1, size = 1, alpha = 0.7) + # mean sst
  scale_x_continuous(name = "Year", breaks = c(1880, 1900, 1920, 1940, 1960, 1980, 2000, 2019)) +
  ylab('SST (°C)') +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  geom_line(data = HADI_year_avg[-151,], aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.5) + # max sst
  geom_line(data = HADI_year_avg[-151,], aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.5) + # min sst
  geom_smooth(data = sst_gam_df, method = "gam", aes(x = year, y = sst), colour = "black", group = 1, size = 1, se = FALSE, formula = y ~ s(x, bs = "cs")) + # smoothed mean temp over all data
  #ggtitle("HadISST (1870 - 2019)") +
  coord_cartesian(xlim = c(1870, 2019)) +
  ggsave("figures/Fig3_HadISST_SST_annual.pdf", width = 6, height = 4)

ggplotly(HadISST_SST_plot)

```

**Figure 3 |** Annual mean SST (HadISST) across reef sites (black line - as calculated using the geom_smooth function fit with a general additive model) and 95% confidence interval (grey ribbon). The <span style="color: #2166ac;">blue</span> line represents the annual minimum SST across sites and the <span style="color: #d6604d;">red</span> line depicts the maximum SST across sites per year. The grey horizontal dotted line represented the overall mean SST of the full dataset, and the grey vertical line denotes when the subset of data matching the Pathfinder SST begins.


```{r had combined figure, include=FALSE}

# Saves the manuscript version of the HadISST historic SST
plot_grid(hadplot_markdown, HadISST_SST_plot, ncol = 1, labels = c("A", "B"), align = "hv") +
  ggsave("figures/Manuscript_figs/Fig3_SST_trends.pdf", width = 6, height = 7.5)

```


<br/><br/><br/>

### Pathfinder dataset (1981 - 2019)

Pathfinder reports SST twice daily (night and day) at 4km resolution via NOAA National Centers for Environmental Information (NCEI). [Data can be accessed here](https://www.nodc.noaa.gov/SatelliteData/pathfinder4km/). According to their website:

> "L3C is generated with measurements combined from a single instrument into a space-time grid. The dataset was computed with data from the AVHRR instruments on board NOAA's polar orbiting satellite series using an entirely modernized system based on SeaDAS (version 6.4)."

For ease of analysis, monthly mean SSTs per pixel were calculated from the Pathfinder data and saved as a new netCDF file for all downstream analyses. 

```{r Pathfinder raster}

## read in the Pathfinder raster
path_data <- pathfinder_combined_monthly_data_path
data_brick2 <- brick(path_data) # read SST data as rasterbrick
data_brick2 <- crop(data_brick2,extent(Xmin,Xmax,Ymin,Ymax)) # clip rasterbrick for Caribbean region only (see 'spatial subsetting' above)


ncdf_file <- nc_open(path_data)
#ncdf_file

nc_lats <- ncdf_file$dim$lat$vals #other way of looking into the data structure; extracting lats
nc_longs <- ncdf_file$dim$lon$vals #longs here
nc_longs[nc_longs>180] <- nc_longs[nc_longs>180]-360

#time handling
raw_times <- ncdf_file$dim$time$vals # times are seconds after the "start of time"
startoftime <- ncdf_file$dim$time$units # here's what they consider the start of time
nc_times<-as.POSIXct(raw_times, tz="UTC", gsub("seconds since ","", startoftime))
nc_times <- nc_times+3600*3 # to center readings at noon - just cosmetics
nc_close(ncdf_file) # close the file

# temporal subsetting  
start_date2 <- "1981-09-15"
end_date2 <- "2019-12-16"
#end_date2 <- "1982-08-16" # using this one for just a subset of 12 months
start_date2 <- as.POSIXct(start_date2, tz="UTC")
end_date2 <- as.POSIXct(end_date2, tz="UTC")
    
# restrict temporally
Tstart_index2 <- min(which(difftime(nc_times,start_date2)>0))
Tend_index2 <- min(which(difftime(nc_times,end_date2)>0))
data_brick2 <- data_brick2[[Tstart_index2:Tend_index2]]
time <- nc_times[Tstart_index2:Tend_index2]

## Remove NAs and convert to C
KtoC <- function(x){round(x-273.15,2)} # converts the raster from Kelvin to Celsius
NAset <- function(x){x[x < -54]<-NA; return(x)} # Pathfinder uses the value -54 (K) to denote missing data and this function replaces that with NA
data_brick2 <- calc(data_brick2, KtoC) # apply the Kelvin function written above to raster
data_brick2 <- calc(data_brick2, NAset) # apply the NA function written above to raster


# save time component
save(time, nc_times, data_brick2, file = "data/Pathfinder/Pathfinder_times.Rdata")# save the time variables for IDs for running scripts remotely

```

```{r path raster edit and slope calculation - REMOTE, eval=FALSE, include=FALSE}

# ***NOTE***
####--- this portion of the script was run on a high performance computing cluster because of the long runtime needed
####--- see separate R script (Pathfinder_RasterCalculations.R) for instructions (located in the code folder)
####--- the script can be put on a cluster with the Pathfinder netCDF (pathfinder_combined_monthly_data.nc) to run


##########################################

## Remove NAs and convert to C
KtoC <- function(x){round(x-273.15,2)} # converts the raster from Kelvin to Celsius
NAset <- function(x){x[x < -54]<-NA; return(x)} # Pathfinder uses the value -54 (K) to denote missing data and this function replaces that with NA
data_brick2 <- calc(data_brick2, NAset) # apply the NA function written above to raster
data_brick2b <- calc(data_brick2, KtoC) # apply the Kelvin function written above to raster


## Calculate slope of temperature change across time for each pixel
# simple lm function applied to the raster brick to calculate the slope of temperature change over timescale of raster
lm.fun2 <- function(x, time){
  if(is.na(x)){NA} # this removes any NA values from the slope calculations 
  else{
    lm(x~time)$coefficients[2]*60*60*24 # slope here is degrees/day
  }}

raster_slope2 <- calc(data_brick2, function(x)lm.fun2(x, time = time)) # function applied here


## Create dataframe from calculated slope raster in C per decade for plotting
raster_slope2 <- raster_slope2*(365.25*10) # this is currently C per decade
path_slope <- as.data.frame(as(raster_slope2, "SpatialPixelsDataFrame")) # convert to a raster to da$
colnames(path_slope) <- c("sst", "x", "y")


## Save the edited netCDF file and the slope raster/dataframe
## Only uncomment these lines if you want to write over existing files!! 

#writeRaster(data_brick2b, filename = "data/Pathfinder/Pathfinder_monthly_edit.nc", format="CDF", overwrite=FALSE)
#save(path_slope, file = "data/Pathfinder/Pathfinder_slope.Rdata")
#write.csv(path_slope, file = "data/Pathfinder/Pathfinder_slope.csv", row.names=FALSE)

# --------- *Plotting occurs down at the bottom of the markdown file* --------- #

```

```{r path pvalue map df creation, eval=FALSE, include=FALSE}

# ***NOTE***
### This does take a while (~10 minutes), however it can be run locally.

## load in the edited pathfinder raster
#path_brick <- brick(Pathfinder_monthly_edit_path)
path_brick <- brick("/Users/colleen/Dropbox/Git/CaribbeanSST/data/Pathfinder/PathfinderSST_UPDATE_monthly_edit2.nc")
plot(path_brick)
## function to pull the p value per pixel of the simple lm applied to the full Pathfinder raster brick 
pval.fun2 <- function(x, time)
{
  if(is.na(x)){NA} # this removes any NA values from the lm
  else{
    summary(lm(x ~ time))$coefficients[4] # pulls the p value
  }
}
raster_pval2 <- calc(path_brick, function(x)pval.fun2(x, time = time))

# convert the raster to a df for plotting
path_pavl <- as.data.frame(as(raster_pval2, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(path_pavl) <- c("pval", "x", "y")
path_pavl$bins <- cut(path_pavl$pval, breaks = bins, labels = bin_names) # bins the pvales into 6 unique bins for plotting

## save the dataframe to save time
write.csv(path_pavl, file = "data/Pathfinder/Pathfinder_pval2.csv", row.names=FALSE)

# --------- *Plotting occurs down at the bottom of the markdown file* --------- #

```

```{r path SST polygon extraction - REMOTE, eval=FALSE, include=FALSE}

# ***NOTE***
####--- this portion of the script was run on a high performance computing cluster because of the long runtime needed
####--- see separate R script (SSTExtraction_ReefPolygon.R) for instructions (located in the code folder)
####--- the script can be put on a cluster with the edited Pathfinder netCDF (Pathfinder_monthly_edit.nc) to run


##########################################
# If working with a smaller data set, you can run the below code to accomplish the same outcome as the SSTExtraction_ReefPolygon.R script.
# The code below has been adapted to specifically work with the Pathfinder_monthly_edit.nc and Caribbean_reefs.shp files:

## Load the Pathfinder EDIT netCDF as rasterBrick
path_brick <- brick(Pathfinder_monthly_edit_path)

## Create an empty dataframe to populate while running the forloop with the following parameters:
path_df <- data.frame('date' = integer(),
                      'mean' = integer(),
                      'min' = integer(),
                      'max' = integer(),
                      'weighted' = integer(),
                      'difference' = integer(),
                      'polygon' = integer())


## for loop that runs through each raster layer and extracts the SST corresponding to reef polygons
for (i in 1:path_brick@file@nbands) {
  raster <- path_brick[[i]]
  
  mean_sst_vals <- raster::extract(raster, shapes, fun=mean) # calculates a mean SST within each reef polygon
  min_sst_vals <- raster::extract(raster, shapes, fun=min) # minimum SST within each reef polygon
  max_sst_vals <- raster::extract(raster, shapes, fun=max) # maximum SST within each reef polygon
  weighted_mean <- raster::extract(raster, shapes, weights=TRUE, fun=mean) # calculates the weighted mean SST within each reef polygon
  
  df <- data.frame('date' = raster@data@names,
                   'mean' = mean_sst_vals,
                   'min' = min_sst_vals,
                   'max' = max_sst_vals,
                   'weighted' = weighted_mean,
                   'difference' = mean_sst_vals - weighted_mean)
  
  df$polygon <- rownames(df) # names the row with polygon ID (numeric IDs)
  
  path_df <- rbind(path_df, df) # adds the above information for each polygon onto the dataframe containing the other calculated values
}


## Once completed, saves the resulting dataframe as both a .Rdata object and .csv
## *** Only uncomment these lines if you want to write over existing files ***
#save(path_df, file = "Pathfinder_reefs_poly.Rdata")
#write.csv(path_df, file = "Pathfinder_reefs_poly.csv")

```

```{r path GPS extraction, eval=FALSE, include=FALSE}

# ***NOTE***
####--- this portion of the script was run on a high performance computing cluster because of the long runtime (~ 24 minutes)
####--- see separate R script (SSTExtraction_ReefPolygon.R) for instructions (located in the code folder) 
####--- the script can be put on a cluster with the edited Pathfinder netCDF (Pathfinder_monthly_edit.nc) to run


## this is the data frame of extracted SST based on polygons
load("data/Pathfinder/Pathfinder_reefs_poly.Rdata") # load in the extracted Pathfinder SST by polygon dataframe
load("data/Pathfinder/Pathfinder_times.Rdata") # load the Pathfinder time strings

## create dataframe of missing polygon GPS corrdinates to extract from Pathfinder raster
path_poly <- path_df[,c(1,7,5)] # select only the polygon ID, weighted mean SST, and time 
path_poly$polygon <- factor(path_poly$polygon)
path_poly <- spread(path_poly, polygon, weighted) # convert from long to wide format
path_poly$date <- nc_times # add the date/time back into the dataframe
NAcol_path <- colnames(path_poly)[colSums(is.na(path_poly)) > 230] # identify the columns with NA values in more than half of timeframe to pull SST from GPS points instead of polygons
path_reef_gps <- reef_pt %>% filter(L3 == NAcol_path) # select only GPS points of polygons missing SST data above

## converting sampling points to spatial points and applying projection to points
path_LongLat <- cbind(path_reef_gps$X, path_reef_gps$Y) 
path_ReefPTS <- SpatialPoints(path_LongLat)
projection(path_ReefPTS) <- proj


## finding nearest valid pixel that corresponds to reef location
#--- This portion is adapted from Fernando Lima (CIBIO/InBIO, Universidade do Porto)
#---->

## need to load the Pathfinder edited netCDF and read in as raster to extract nearest pixels
path_data <- pathfinder_combined_monthly_data_path
data_brick2 <- brick(path_data) 
month1 <- data_brick2[[2]] # pixels coordinates
pixel_coordinates <- coordinates(month1)

# delete coordinates where data is missing (NA)
data <- raster::extract(month1, pixel_coordinates) # extract data for all pixels
pixel_coordinates <- pixel_coordinates[!is.na(data),] # check for NAs and delete those entries from the "pixel.coordinates" list

# create new sampling points, shifted to the center of the pixel they fall on, or to the near pixel in case that one is NA
path_ReefPTS_shifted <- vector()
# loop cycling through sampling points
for (p in 1:length(path_ReefPTS)) {
  # geodesic distances
  distances <- rdist.earth(coordinates(path_ReefPTS[p]), pixel_coordinates, miles=FALSE)
  # coordinates of the pixel that is at shorter distance
  shifted_coordinates <- pixel_coordinates[which.min(distances),]
  # assigning those coordinates to a new item
  cmd <- paste0("sp.", p, "<-shifted_coordinates")
  eval(parse(text=cmd))
  cmd <- paste0("path_ReefPTS_shifted<-rbind(path_ReefPTS_shifted,sp.", p, ")")
  eval(parse(text = cmd))
  print(p) 
}
#---->

## extract SST from Pathfinder by shifted reef GPS points
path_sst <- raster::extract(data_brick2, path_ReefPTS_shifted) 


## convert the data matrix to a xts object, then a dataframe
path_sst_xts <- xts(t(path_sst), time) #t is used to transpose the matrix because xts assumes dates are along the lines, not columns
colnames(path_sst_xts) <- reef_gps$L3 #ID the columns
path_sst_df <- data.frame(date=index(t(path_sst_xts)), coredata(t(path_sst_xts)))
path_sst_df$polygon <- factor(reef_gps$L3) #ID the columns
path_sst_df$date <- NULL


## Once completed, saves the resulting dataframe as both a .Rdata object
## *** Only uncomment these lines if you want to write over existing files ***
#save(path_sst_df, path_sst, file = "Pathfinder_reef_poly_gps.Rdata")

```

```{r path, eval=FALSE, include=FALSE}

load("data/Pathfinder/Pathfinder_reef_poly_gps.Rdata") # load in the SST extracted from GPS coordinates missing from polygon extraction

## Convert the dataframe from wide to long (use head()/tail() to put the accurate start and end column names)
#head(path_sst_df)
#tail(path_sst_df)
path_sst_long <- gather(path_sst_df, date, sst, X1981.09.15.17.34.40:X2019.12.16.11.45.55 )

## Calculate mean SST per polygon ID (using the GPS extracted values)
path_gps <- aggregate(path_sst_long, by = list(path_sst_long$date, path_sst_long$polygon), FUN = mean)[,c(1:2,5)]

## Modify dataframe to have seperate columns for different time parameters
path_gps2 <- path_gps %>% separate(Group.1, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
path_gps2$date <- paste(path_gps2$year, path_gps2$month, path_gps2$day, sep = ".") # create date column 
path_gps2 <- path_gps2[, c(7,9,8)] # select for polygon ID (Group.2), date, and sst columns
path_gps2 <- spread(path_gps2, Group.2, sst) # convert from long to wide


## Recombine the polygon and GPS extracted data (need to recreate the path_poly dataframe if previous chunk was run remotely)
load("data/Pathfinder/Pathfinder_reefs_poly.Rdata") # load in the extracted Pathfinder SST by polygon dataframe
path_poly <- path_df[,c(1,7,5)] # select only the polygon ID, weighted mean SST, and time 
path_poly$polygon <- factor(path_poly$polygon)
path_poly <- spread(path_poly, polygon, weighted) # convert from long to wide format
path_poly$date <- nc_times # add the date/time back into the dataframe
NAcol_path <- colnames(path_poly)[colSums(is.na(path_poly)) > 230] 
path_poly_narm <- select(path_poly, -c(NAcol_path)) # remove the NA columns before adding them back in below
path_poly_narm <- path_poly_narm %>% separate(date, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
path_poly_narm$year <- paste(path_poly_narm$year, path_poly_narm$month, path_poly_narm$day, sep = ".") # create date column
path_poly_narm <- path_poly_narm[,-c(2:6)]


## Join the polygon and GPS extracted dataframes into final SST by reef location dataframe
path_full <- path_gps2 %>% 
  left_join(path_poly_narm, by = c("date" = "year"))
path_full$year <- NULL
path_full$date.y <- NULL

#save(had_full, file = "data/HadISST/HadISST_reefs_gps.Rdata")

```


```{r UPDATED path GPS extraction, eval=FALSE, include=FALSE}

reef_gps <- read.csv("data/ReefData/CaribbeanReef_points.csv") # read in FULL reef locations csv

## convert sampling points to spatial points and applying projection to points
LongLat <- cbind(reef_gps$lon, reef_gps$lat) 
ReefPTS <- SpatialPoints(LongLat)
proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84"
projection(ReefPTS) <- proj

#  ## shift points (some pixels fall on land so finding nearest valid pixels
#  # pixels coordinates
#  first_day <- data_brick2[[1]]
#  pixel_coordinates <- coordinates(first_day)
#  
#  # delete coordinates where data is missing (NA)
#  data <- raster::extract(first_day, pixel_coordinates) # extract data for all pixels
#  pixel_coordinates <- pixel_coordinates[!is.na(data),] # remove NA from the "pixel.coordinates" list
#  
#  # Create new sampling points, shifted to the center of the pixel they fall on, or to the near pixel in case that one is NA
#  ReefPTS_shifted <- vector()
#  #loop cycling through sampling points
#  for (p in 1:length(ReefPTS)) {
#    #geodesic distances
#    distances <- rdist.earth(coordinates(ReefPTS[p]),pixel_coordinates,miles=FALSE)
#    #coordinates of the pixel that is at shorter distance 
#    shifted_coordinates <- pixel_coordinates[which.min(distances),]
#    #assigning those coordinates to a new item
#    cmd <- paste0("sp.",p,"<-shifted_coordinates")
#    eval(parse(text=cmd))
#    #points(pt[1],pt[2])
#    cmd <- paste0("ReefPTS_shifted<-rbind(ReefPTS_shifted,sp.",p,")")
#    eval(parse(text = cmd))
#  }
#  

## extract data from the sst brick with the sampling points shifted
path_sst <- raster::extract(data_brick2, ReefPTS)   # path_sst <- raster::extract(data_brick2, ReefPTS_shifted)


## convert the data matrix to a final dataframe
path_sst_xts <- xts(t(path_sst), time) # t is used to transpose the matrix because xts assumes dates are along the lines, not columns
path_sst_df <- data.frame(date=index(t(path_sst_xts)), coredata(t(path_sst_xts))) # convert xts object to dataframe
path_sst_df$reef <- factor(seq(1, length(path_sst_df$date), 1)) # ID the columns to identify unique reefs
path_sst_df$date <- NULL # remove this column since it is repetitive 
path_sst_long <- gather(path_sst_df, date, sst, X1981.09.15.17.34.40:X2019.12.16.11.45.55) # convert from wide to long format

## update the dataframe for saving
path_gps <- path_sst_long %>% separate(date, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
path_gps$date <- paste(path_gps$year, path_gps$month, path_gps$day, sep = ".") # creates a full date column (XYear.Month.Day)
path_gps <- path_gps[, -c(2:7)] # remove columns for hour, minute, and seconds (we won't use these)
path_gps <- spread(path_gps, reef, sst)

## save the final dataframe (.csv or Rdata)
#write.csv(path_gps, file = "data/Pathfinder/Pathfinder_reefs_SST_update.csv") # to save file as .csv
save(path_gps, file = "data/Pathfinder/Pathfinder_reefs_SST_update2.Rdata") # to save file as Rdata (I saved as Rdata since it is large)

```


<br/>
  
```{r path monthly SST dataframe construction}

load("data/Pathfinder/Pathfinder_reefs_SST_update2.Rdata")

path_full <- path_gps # only need to use this to make the UPDATED reef SST dataframe compatible below

## create a new dataframe of simple stats per time
path_full2 <- data.frame("date" = path_full[,1],
                        "mean_temp" = rowMeans(path_full[,-1], na.rm = TRUE),
                        "max_temp" = apply(path_full[,-1], 1, FUN=max, na.rm = TRUE),
                        "min_temp" = apply(path_full[,-1], 1, FUN=min, na.rm = TRUE),
                        "n" = length(path_full[,-1]))

path_full2 <- path_full2 %>% separate(date, c("year", "month","day"), convert = TRUE) # create year, month, and day column columns
path_full2$year <- as.numeric(gsub("\\X", "", path_full2$year)) # convert the year column to numerics and remove 'X'
path_full2$month2 <- factor(path_full2$month) # make a month as a factor column for plotting

```

```{r path monthly SST per year, fig.align='center'}

#### Data visualization of monthly SST per year #### 

# calculate summary statistic per month across years
Path_month_avg <- path_full2 %>% 
  group_by(month) %>% 
  summarize(mean = mean(mean_temp, na.rm = TRUE),
            sd = sd(mean_temp, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se)

# make year integer for better plotting
path_full2$year <- as.integer(path_full2$year)

## create plots of monthly Pathfinder per year
# markdown plot
pathplot_markdown <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 45, hjust = 1), text = element_text(size = 14)) +
  theme(legend.position = c(0.065, 0.85), legend.key.size = unit(0.3, "cm"), legend.background = element_rect(fill = NA), plot.title = element_text(size = 12)) + # legend theme
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  geom_line(data = path_full2, aes(x = month, y = mean_temp, group = year, colour = year), alpha = 0.6, size = 0.4) +
  scale_colour_gradient2("", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(path_full2$year), space="Lab") +
  #geom_ribbon(data = Path_month_avg, aes(x = month, ymin = lowerci, ymax = upperci), colour = "black", alpha = 0.6, linetype = 2) + 
  #geom_line(data = Path_month_avg, aes(x = month, y = mean), colour = "black", group = 1, size = 1.5) +
  scale_x_continuous(name = "Month", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  ylab('SST (°C)') +
  ggtitle("Pathfinder (1980 - 2019)") + 
  theme(plot.title = element_text(size = 13)) +
  ggsave("figures/Fig4_Pathfinder_SST_monthly.pdf", width = 6, height = 3.5)

ggplotly(pathplot_markdown) # this plots an interactive version of the map in the Rmarkdown HTML output

# create version of the plot for creating a GIF of Pathfinder data
path_plot_gif <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  geom_line(data = path_full2, aes(x = month, y = mean_temp, group = year, colour = year), size = 1) +
  scale_colour_gradient2("Year", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(path_full2$year), space="Lab") +
  #geom_ribbon(data = Path_month_avg, aes(x = month, ymin = lowerci, ymax = upperci), colour = "black", alpha = 0.6, linetype = 2) + 
  #geom_line(data = Path_month_avg, aes(x = month, y = mean), colour = "black", group = 1, size = 1.5) +
  scale_x_continuous(name = "Month", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  ylab('SST (°C)')


#### Summary information for 'Results' text:

## Monthly SST min/max/mean
path_mean<- path_full2 %>% 
  group_by(month) %>% 
  summarise("mean" = mean(mean_temp, na.rm = TRUE))

min(path_mean$mean)
max(path_mean$mean)
mean(path_mean$mean)

```



**Figure 4 |** Mean SST across coral reefs sites at each monthly sampling event (Pathfinder dataset) from 1870 to 2019. Year is represented by colour of each line, changing from <span style="color: #2166ac;">blue</span> to <span style="color: #d6604d;">red</span> in more recent years. Maximum SST generally occurs for the region between August and October and the minimum SST occurs between January and March.


```{r path GIF, eval=FALSE, include=FALSE}

## below is code to transform the Pathfinder monthly SST plot into a GIF (not shown in the Rmarkdown file, but saved in the figures folder)
# SST is plotted one year at a time in order in the GIF

path_gif <- path_plot_gif + 
  transition_time(year) +
  labs(title = "Year: {frame_time} (Pathfinder)") +
  shadow_mark(alpha = 0.1, size = 0.5)

animate(path_gif, fps = 10, nframes = 100, end_pause = 3, width = 325, height = 200)
anim_save("figures/Pathfinder.gif")

```

<br/>
  
```{r path annual SST}

## construct df for the GAM smoothing of mean SST
sst_gam_df <- gather(path_full, reef, sst, `1`:`5607`)
sst_gam_df$date <- gsub("\\X", "", sst_gam_df$date) # convert year to numeric and remove 'X'
sst_gam_df <- sst_gam_df %>% separate(date, c("year", "month","day"), convert = TRUE) # create year, month, and day column columns
sst_gam_df <- subset(sst_gam_df, year != "2020")
sst_gam_df <- subset(sst_gam_df, year != "1981")


#### Data visualization per year across months #### 

# calculate summary statistic per month across years
Path_year_avg <- path_full2 %>% 
  group_by(year) %>% 
  summarize(mean = mean(mean_temp, na.rm = TRUE),
            max = max(mean_temp, na.rm = TRUE),
            min = min(mean_temp, na.rm = TRUE),
            sd = sd(mean_temp, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se,
         range = max - min)


## plot with smoothed trend
Pathfinder_SST_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size = 14)) +
  #geom_vline(xintercept = 1981, colour = "lightgrey") +
  geom_hline(yintercept = mean(Path_year_avg[-1,]$mean), colour = "grey", linetype = 2) +
  geom_ribbon(data = Path_year_avg[-1,], aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.3, linetype = 1) + 
  #geom_line(data = Path_year_avg[-1,], aes(x = year, y = mean), colour = "black", group = 1, size = 1, alpha = 0.7) + # mean sst
  scale_x_continuous(name = "Year") +
  ylab('SST (°C)') +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.5) + # max sst
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.5) + # min sst
  geom_smooth(data = sst_gam_df, method = "gam", aes(x = year, y = sst), colour = "black", group = 1, size = 1, se = FALSE, formula = y ~ s(x, bs = "cs")) + # smoothed mean temp over all data
  #ggtitle("Pathfinder (1870 - 2019)") +
  coord_cartesian(xlim = c(1981, 2019)) +
  ggsave("figures/Fig5_Pathfinder_SST_annual.pdf", width = 6, height = 4)

ggplotly(Pathfinder_SST_plot)

```

**Figure 5 |** Smoothed annual mean SST (Pathfinder) across reef sites (black line) and 95% confidence interval (grey ribbon). The <span style="color: #2166ac;">blue</span> line represents the annual minimum SST across sites and the <span style="color: #d6604d;">red</span> line depicts the maximum SST across sites per year.

```{r path combined figure, include=FALSE}

# Saves the manuscript version of the Pathfinder historic SST
plot_grid(pathplot_markdown, Pathfinder_SST_plot, ncol = 1, labels = c("A", "B"), align = "hv") +
  ggsave("figures/Supplemental_figs/Pathfinder_SST_trends.pdf", width = 6, height = 7.5)

```

<br/><br/><br/>



### <span style="color: #313695;">Combined SST datasets</span>

Here, I have plotted the same SST trend on reefs extracted from both the HadISST (**Figure 3**) and the Pathfinder (**Figure 5**) datasets for comparison of recorded temperature values. The HadISST dataset is plotted in the background in lighter colours and Pathfinder is plotted in darker colours on top. Since the Pathfinder data has a finer resolution, differences between absolute temperatures is expected. However, overall mean SST recorded on reefs is similar between the two datasets (dotted line). 

```{r combined annual SST plot}

## plot with smoothed trend
combo_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  # add the HadISST dataset
  geom_hline(yintercept = mean(HADI_year_avg[-151,]$mean), colour = "darkgrey", linetype = 2) +
  geom_ribbon(data = HADI_year_avg[-151,], aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.05, linetype = 1) + 
  geom_line(data = HADI_year_avg[-151,], aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.5, alpha = 0.3) +
  geom_line(data = HADI_year_avg[-151,], aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.5, alpha = 0.3) + 
  geom_line(data = HADI_year_avg[-151,], aes(x = year, y = mean), colour = "darkgrey", group = 1, size = 0.5, alpha = 0.3) + 
  geom_smooth(data = HADI_year_avg[-151,], method = "gam", aes(x = year, y = mean), formula = y ~ s(x, bs = "cs"), colour = "darkgrey", group = 1, size = 1, se = FALSE, alpha = 0.3) +
  # add the Pathfinder dataset on top
  geom_hline(yintercept = mean(Path_year_avg[-1,]$mean), colour = "black", linetype = 2) +
  geom_ribbon(data = Path_year_avg[-1,], aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.3, linetype = 1) +
  scale_x_continuous(name = "Year", breaks = c(1880, 1900, 1920, 1940, 1960, 1980, 2000, 2019)) +
  ylab('SST (°C)') +
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.5) +
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.5) + 
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = mean), colour = "black", group = 1, size = 0.5) + 
  geom_smooth(data = Path_year_avg[-1,], method = "gam", aes(x = year, y = mean), formula = y ~ s(x, bs = "cs"), colour = "black", group = 1, size = 1, se = FALSE) +
  ggtitle("Caribbean coral reefs historic SST trends") +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  coord_cartesian(xlim = c(1870, 2019)) +
  ggsave("figures/Supplemental_figs/Both_SST_trends.pdf", width = 6, height = 4) # I have not saveed this figure outside the Rmarkdown file

ggplotly(combo_plot)

```


<br/><br/><br/>


## <span style="color: #313695;">Overall Caribbean SST trends</span>{.tabset}

A simple linear model was applied to each grid through time using a forloop to calculate the slope of SST change. Plots below are adjusted to show slope of $^\circ$C per decade for each timespan. Additionally, the HadISST dataset was subset to to include the same time range available for Pathfinder for comparison between the two datasets. 


### HadISST dataset (1870 - 2019)

```{r had SST map, message=FALSE, warning=FALSE}

had_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_slope, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC per decade", palette = "RdYlBu", limits = c(-0.03, 0.09)) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(ggtitle(paste0("Caribbean warming rate (1870-2019)")))

```

```{r had SST pval map, message=FALSE, warning=FALSE}

had_pval_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_pavl, aes(x = x, y = y, fill = bins), alpha=0.8, interpolate = TRUE) + 
  scale_fill_brewer("P-value", palette = "GnBu") +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("SST slope significance"))

```

```{r had SST map combo, message=FALSE, warning=FALSE, fig.align='center', fig.width=12, fig.height=6}

plot_grid(had_map, had_pval_map, labels = c("A", "B")) +
  ggsave("figures/Fig6_HadISST_map.pdf", width = 14, height = 5)

```


**Figure 6 |** Change in SST ($^\circ$C / decade) over the timespand of the HadISST dataset (`r format.Date(start_date, "%Y")` - `r format.Date(end_date, "%Y")`) and the resulting significance of the regression (**B**). The average temperature change for the entire region is `r round(mean(had_slope$sst), 2)` ($\pm$ `r round(sd(had_slope$sst), 3)`). 

<br/>

```{r had SST map subset (1981-2019), message=FALSE, warning=FALSE}

had_map_sub <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_slope_sub, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC per decade", palette = "YlOrRd", trans = "reverse", limits = c(max(had_slope_sub$sst), min(had_slope_sub$sst))) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("SST slope from ", format.Date(start_dateb, "%Y"), " to ", format.Date(end_date, "%Y")," (HadISST)"))

```

```{r had SST pval map subset (1981-2019), message=FALSE, warning=FALSE}

had_pval_map_sub <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_pval_sub, aes(x = x, y = y, fill = bins), alpha=0.8, interpolate = TRUE) + 
  scale_fill_brewer("P-value", palette = "GnBu") +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("SST slope significance"))

```

```{r had SST map subset combo, message=FALSE, warning=FALSE, fig.align='center', fig.width=12, fig.height=6}

plot_grid(had_map_sub, had_pval_map_sub, labels = c("A", "B")) +
  ggsave("figures/Fig7_HadISST_subset_map.pdf", width = 14, height = 5)

```

**Figure 7 |** Change in SST ($^\circ$C / decade) over the subset timespand of the HadISST dataset (subset: `r format.Date(start_dateb, "%Y")` - `r format.Date(end_date, "%Y")`) (**A**) and the resulting significance of the regression (**B**). The average temperature change for the entire region is `r round(mean(had_slope_sub$sst), 2)` ($\pm$ `r round(sd(had_slope_sub$sst), 3)`). 

<br/><br/>

---

<br/>

### Pathfinder dataset (1981 - 2019)

```{r path SST map, message=FALSE, warning=FALSE}

load("data/Pathfinder/Pathfinder_slope_UPDATE2.Rdata") # load Rdata of the modified Pathfinder raster
#path_slope <- read.csv("/Users/colleen/Dropbox/Coauthor\ Publication/Precht_Review/data/Pathfinder/path_slope3.csv", header = TRUE) # or load csv

path_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = path_slope, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC per decade", palette = "YlOrRd", trans = "reverse", limits = c(max(had_slope_sub$sst), min(had_slope_sub$sst))) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("SST slope from ", format.Date(start_date2, "%Y"), " to ", format.Date(end_date2, "%Y")," (Pathfinder)"))

```

```{r path SST pval map subset (1981-2019), message=FALSE, warning=FALSE}

path_pavl <- read.csv("data/Pathfinder/Pathfinder_pval.csv", header = TRUE) # read in the saved .csv of the dataframe

path_pval_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = path_pavl, aes(x = x, y = y, fill = bins), alpha=0.8, interpolate = TRUE) + 
  scale_fill_brewer("P-value", palette = "GnBu") +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("SST slope significance"))

```

```{r path SST map subset combo, message=FALSE, warning=FALSE, fig.align='center', fig.width=12, fig.height=6}

plot_grid(path_map, path_pval_map, labels = c("A", "B")) +
  ggsave("figures/Fig8_Pathfinder_map.pdf", width = 14, height = 5)

```


**Figure 8 |** Change in SST ($^\circ$C / decade) over the timespand of the Pathfinder dataset (`r format.Date(start_date2, "%Y")` - `r format.Date(end_date2, "%Y")`) and the resulting significance of the regression (**B**). The average temperature change for the entire region is `r round(mean(path_slope$sst), 2)` ($\pm$ `r round(sd(path_slope$sst), 3)`). 

<br/><br/><br/>


## <span style="color: #313695;">Additional exploratory analyses</span>{.tabset}

### Historic maximum SST (map)

#### HadISST (1870 - 2019)

```{r HadISST full max SST df}

##### Maximum SST extraction and dataframe

## Create raster layer of the max SST per pixel throughout all time
raster_max <- max(data_brick)

## Convert the raster of SST to a df for plotting
had_max <- as.data.frame(as(raster_max, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_max) <- c("max", "x", "y")



##### Maximum SST extraction and dataframe

## Convert the raster of observational year to a df for plotting
had_max_yr <- read.csv("data/HadISST/HadISST_MaxSST_layers.csv", header = TRUE)

## Create dataframe of layer and year
load("data/HadISST/HadISST_times.Rdata") # load in the time data again for HadISST 
times_had <- data.frame("time" = time, "layer" = seq(1,1801)) # dataframe of year and layer ID
times_had <- times_had %>% separate(time, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
times_had <- times_had[,-c(3:6)] # subset out the day/time columns

## Update max date dataframe with time instead of layer
had_max_time <- merge(had_max_yr, times_had, layer = layer) # merge together the dataframes so that corresponding year matches
had_max_time$year <- as.numeric(had_max_time$year) # convert year to numeric
had_max_time$month <- factor(had_max_time$month) # convert month to factor
had_max_time <- had_max_time %>% mutate(month = recode(month, '01' = 'Jan', '02' = 'Feb', '03' = 'Mar', '04' = 'Apr', '05' = 'May', '06' = 'Jun', '07' = 'Jul', '08' = 'Aug', '09' = 'Sep', '10' = 'Oct', '11' = 'Nov', '12' = 'Dec')) # replace month number with name

```

```{r had max SST map, message=FALSE, warning=FALSE, fig.align='center' , fig.width=12, fig.height=6}

### Plot the max SST per pixel (full HadISST range)
had_max_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_max, aes(x = x, y = y, fill = max), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC", palette = "Reds", trans = "reverse", limits = c(35, 26)) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("Maximum recorded SST (", format.Date(start_date, "%Y"), " - ", format.Date(end_date, "%Y"),")")) 


## Plot the year of the max SST
had_max_year_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_max_time, aes(x = x, y = y, fill = year), alpha=0.8) + 
  scale_fill_distiller("", palette = "YlGnBu", trans = "reverse", breaks = c(1900, 1950, 2000), limits = c(2020, 1870)) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle("Year of maximum SST") 

  
## Plot the month of the max SST
had_max_month_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_max_time, aes(x = x, y = y, fill = month), alpha=0.8) + 
  scale_fill_brewer("", palette = "BrBG") +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle("Month of maximum SST") 


## Combined max SST and year observed plot
plot_grid(had_max_plot, had_max_year_plot, had_max_month_plot, labels = c("A", "B", "C"), ncol = 3) +
  ggsave("figures/Fig9_HadISST_maxSST.pdf", width = 14, height = 5)

```

**Figure 9 |** Maximum SST ($^\circ$C) recorded in the entire HadISST dataset (from `r format.Date(start_date, "%Y")` to `r format.Date(end_date, "%Y")`) within each grid (**A**). The year (**B**) and month (**C**) in which each maximum SST was observed is also depicted. 


<br/> 

#### HadISST (1981 - 2019)

```{r HadISST sub max SST df}

##### Maximum SST extraction and dataframe (HadISST subset)

## Create raster layer of the max SST per pixel throughout all time
raster_max_sub <- max(data_brickb)

## Convert the raster of SST to a df for plotting
had_max_sub <- as.data.frame(as(raster_max_sub, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_max_sub) <- c("max", "x", "y")



##### Maximum SST extraction and dataframe (HadISST subset)

## Convert the raster of observational year to a df for plotting
had_max_sub_yr <- read.csv("data/HadISST/HadISST_MaxSST_subset_layers.csv", header = TRUE)

## Create dataframe of layer and year
load("data/HadISST/HadISST_times.Rdata") # load in the time data again for HadISST 
times_had <- data.frame("time" = time[1340:1801], "layer" = seq(1, 462)) # dataframe of year and layer ID
times_had <- times_had %>% separate(time, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
times_had <- times_had[,-c(3:6)] # subset out the day/time columns

## Update max date dataframe with time instead of layer
had_max_sub_time <- merge(had_max_sub_yr, times_had, layer = layer) # merge together the dataframes so that corresponding year matches
had_max_sub_time$year <- as.numeric(had_max_sub_time$year) # convert year to numeric
had_max_sub_time$month <- factor(had_max_sub_time$month) # convert month to factor
had_max_sub_time <- had_max_sub_time %>% mutate(month = recode(month, '01' = 'Jan', '02' = 'Feb', '03' = 'Mar', '04' = 'Apr', '05' = 'May', '06' = 'Jun', '07' = 'Jul', '08' = 'Aug', '09' = 'Sep', '10' = 'Oct', '11' = 'Nov', '12' = 'Dec')) # replace month number with name

```

```{r had max subset SST map, message=FALSE, warning=FALSE, fig.align='center' , fig.width=12, fig.height=6}

### Plot the max SST per pixel (subset HadISST range)
had_max_subset_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_max_sub, aes(x = x, y = y, fill = max), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC", palette = "Reds", trans = "reverse", limits = c(35, 26)) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("Maximum recorded SST (", format.Date(start_dateb, "%Y"), " - ", format.Date(end_date, "%Y"),")")) 


## Plot the year of the max SST (subset HadISST range)
had_max_subset_year_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_max_sub_time, aes(x = x, y = y, fill = year), alpha=0.8) + 
  scale_fill_distiller("", palette = "YlGnBu", trans = "reverse", breaks = c(1900, 1950, 2000), limits = c(2020, 1870)) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle("Year of maximum SST") 

  
## Plot the month of the max SST (subset HadISST range)
had_max_subset_month_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_max_sub_time, aes(x = x, y = y, fill = month), alpha=0.8) + 
  scale_fill_brewer("", palette = "BrBG") +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle("Month of maximum SST") 


## Combined max SST and year observed plot
plot_grid(had_max_subset_plot, had_max_subset_year_plot, had_max_subset_month_plot, labels = c("A", "B", "C"), ncol = 3) +
  ggsave("figures/Fig10_HadISST_maxSST_subset.pdf", width = 14, height = 5)

```

**Figure 10 |** Maximum SST ($^\circ$C) recorded in the subset HadISST dataset (`r format.Date(start_date, "%Y")` - `r format.Date(end_date, "%Y")`) within each grid (**A**). The year (**B**) and month (**C**) in which each maximum SST was observed is also depicted. 


<br/>

#### Pathfinder (1981 - 2019)

```{r path sub max SST df}

##### Maximum SST extraction and dataframe (Pathfinder)

## Create raster layer of the max SST per pixel throughout all time
path_brick <- brick(Pathfinder_monthly_edit_path)
raster_max <- max(path_brick, na.rm = TRUE)

## Convert the raster of SST to a df for plotting
path_max <- as.data.frame(as(raster_max, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(path_max) <- c("max", "x", "y")



###### Maximum SST extraction and dataframe (Pathfinder)
#
### forloop takes about 1.75 hours
#
### Convert the raster of observational year to a df for plotting
##path_max_yr <- read.csv("data/Pathfinder/Pathfinder_MaxSST_layers.csv", header = TRUE)
#path_max_brick <- brick("data/Pathfinder/Pathfinder_MaxSST_layers.nc")[[1]]
#
#plot(path_max_brick)
#path_max_layer <- as.data.frame(as(path_max_brick, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
#colnames(path_max_layer) <- c("layer", "x", "y")
#
### Create dataframe of layer and year
#load("data/Pathfinder/Pathfinder_times.Rdata") # load in the time data again for Pathfinder 
#times_path <- data.frame("time" = time, "layer" = seq(1, 460)) # dataframe of year and layer ID
#times_path <- times_path %>% separate(time, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
#times_path <- times_path[,-c(3:6)] # subset out the day/time columns
#
### Update max date dataframe with time instead of layer
#path_max_time <- merge(path_max_yr, times_had, layer = layer) # merge together the dataframes so that corresponding year matches
#path_max_time$year <- as.numeric(path_max_time$year) # convert year to numeric
#path_max_time$month <- factor(path_max_time$month) # convert month to factor
#path_max_time <- path_max_time %>% mutate(month = recode(month, '01' = 'Jan', '02' = 'Feb', '03' = 'Mar', '04' = 'Apr', '05' = 'May', '06' = 'Jun', #'07' = 'Jul', '08' = 'Aug', '09' = 'Sep', '10' = 'Oct', '11' = 'Nov', '12' = 'Dec')) # replace month number with name

```

```{r path max SST map, message=FALSE, warning=FALSE, fig.align='center' , fig.width=12, fig.height=6}

### Plot the max SST per pixel
path_max_subset_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = path_max, aes(x = x, y = y, fill = max), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC", palette = "Reds", trans = "reverse", limits = c(35, 26)) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("Maximum recorded SST (", format.Date(start_dateb, "%Y"), " - ", format.Date(end_date, "%Y"),")")) 
path_max_subset_plot


### Plot the year of the max SST 
#path_max_subset_year_plot <- ggplot() +  
#  theme_bw() +
#  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = #element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
#  geom_raster(data = path_max_time, aes(x = x, y = y, fill = year), alpha=0.8) + 
#  scale_fill_distiller("", palette = "YlGnBu", trans = "reverse", breaks = c(1900, 1950, 2000), limits = c(2020, 1870)) +
#  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
#  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
#  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
#  ylab("Latitude") +
#  xlab("Longitude") +
#  ggtitle("Year of maximum SST") 
#
#
### Plot the month of the max SST
#path_max_subset_month_plot <- ggplot() +  
#  theme_bw() +
#  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = #element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
#  geom_raster(data = path_max_time, aes(x = x, y = y, fill = month), alpha=0.8) + 
#  scale_fill_brewer("", palette = "BrBG") +
#  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
#  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
#  ylab("Latitude") +
#  xlab("Longitude") +
#  ggtitle("Month of maximum SST") 
#
#
### Combined max SST and year observed plot
#plot_grid(path_max_subset_plot, path_max_subset_year_plot, path_max_subset_month_plot, labels = c("A", "B", "C"), ncol = 3) +
#  ggsave("figures/Fig11_Pathfinder_maxSST_subset.pdf", width = 14, height = 5)

```

**Figure 11 |** Maximum SST ($^\circ$C) recorded in the subset Pathfinder dataset (`r format.Date(start_date2, "%Y")` - `r format.Date(end_date2, "%Y")`) within each grid (**A**).

<br/><br/>

---


### Historic minimum SST (map)

#### HadISST (1870 - 2019)

```{r HadISST full min SST df}

##### Minimum SST extraction and dataframe

## Create raster layer of the min SST per pixel throughout all time
raster_min <- min(data_brick, na.rm = TRUE)

## Convert the raster of SST to a df for plotting
had_min <- as.data.frame(as(raster_min, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_min) <- c("min", "x", "y")



##### Minimum SST extraction and dataframe

## Convert the raster of observational year to a df for plotting
had_min_yr <- read.csv("data/HadISST/HadISST_MinSST_layers.csv", header = TRUE)

## Create dataframe of layer and year
load("data/HadISST/HadISST_times.Rdata") # load in the time data again for HadISST 
times_had <- data.frame("time" = time, "layer" = seq(1,1801)) # dataframe of year and layer ID
times_had <- times_had %>% separate(time, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
times_had <- times_had[,-c(3:6)] # subset out the day/time columns

## Update min date dataframe with time instead of layer
had_min_time <- merge(had_min_yr, times_had, layer = layer) # merge together the dataframes so that corresponding year matches
had_min_time$year <- as.numeric(had_min_time$year) # convert year to numeric
had_min_time$month <- factor(had_min_time$month) # convert month to factor
had_min_time <- had_min_time %>% mutate(month = recode(month, '01' = 'Jan', '02' = 'Feb', '03' = 'Mar', '04' = 'Apr', '05' = 'May', '06' = 'Jun', '07' = 'Jul', '08' = 'Aug', '09' = 'Sep', '10' = 'Oct', '11' = 'Nov', '12' = 'Dec')) # replace month number with name

```

```{r had min SST map, message=FALSE, warning=FALSE, fig.align='center' , fig.width=12, fig.height=6}

### Plot the min SST per pixel (full HadISST range)
had_min_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_min, aes(x = x, y = y, fill = min), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC", palette = "Blues", limits = c(5, 27)) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("Minimum recorded SST (", format.Date(start_date, "%Y"), " - ", format.Date(end_date, "%Y"),")")) 


## Plot the year of the min SST
had_min_year_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_min_time, aes(x = x, y = y, fill = year), alpha=0.8) + 
  scale_fill_distiller("", palette = "YlGnBu", trans = "reverse", breaks = c(1900, 1950, 2000), limits = c(2020, 1870)) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle("Year of minimum SST") 


## Plot the month of the min SST
had_min_month_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_min_time, aes(x = x, y = y, fill = month), alpha=0.8) + 
  scale_fill_brewer("", palette = "BrBG") +
  guides(fill = guide_legend(nrow = 2)) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle("Month of minimum SST") 


## Combined min SST and year observed plot
plot_grid(had_min_plot, had_min_year_plot, had_min_month_plot, labels = c("A", "B", "C"), ncol = 3) +
  ggsave("figures/Fig12_HadISST_minSST.pdf", width = 14, height = 5)

```

**Figure 12 |** Minimum SST ($^\circ$C) recorded in the entire HadISST dataset (from `r format.Date(start_date, "%Y")` to `r format.Date(end_date, "%Y")`) within each grid (**A**). The year (**B**) and month (**C**) in which each minimum SST was observed is also depicted. 


<br/>

#### HadISST (1981 - 2019)

```{r HadISST sub min SST df}

##### Minimum SST extraction and dataframe (HadISST subset)

## Create raster layer of the min SST per pixel throughout all time
raster_min_sub <- min(data_brickb, na.rm = TRUE)

## Convert the raster of SST to a df for plotting
had_min_sub <- as.data.frame(as(raster_min_sub, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_min_sub) <- c("min", "x", "y")



##### Minimum SST extraction and dataframe (HadISST subset)

## Convert the raster of observational year to a df for plotting
had_min_sub_yr <- read.csv("data/HadISST/HadISST_MinSST_subset_layers.csv", header = TRUE)

## Create dataframe of layer and year
load("data/HadISST/HadISST_times.Rdata") # load in the time data again for HadISST 
times_had <- data.frame("time" = time[1340:1801], "layer" = seq(1, 462)) # dataframe of year and layer ID
times_had <- times_had %>% separate(time, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
times_had <- times_had[,-c(3:6)] # subset out the day/time columns

## Update min date dataframe with time instead of layer
had_min_sub_time <- merge(had_min_sub_yr, times_had, layer = layer) # merge together the dataframes so that corresponding year matches
had_min_sub_time$year <- as.numeric(had_min_sub_time$year) # convert year to numeric
had_min_sub_time$month <- factor(had_min_sub_time$month) # convert month to factor
had_min_sub_time <- had_min_sub_time %>% mutate(month = recode(month, '01' = 'Jan', '02' = 'Feb', '03' = 'Mar', '04' = 'Apr', '05' = 'May', '06' = 'Jun', '07' = 'Jul', '08' = 'Aug', '09' = 'Sep', '10' = 'Oct', '11' = 'Nov', '12' = 'Dec')) # replace month number with name

```

```{r had min subset SST map, message=FALSE, warning=FALSE, fig.align='center' , fig.width=12, fig.height=6}

### Plot the min SST per pixel (subset HadISST range)
had_min_subset_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_min_sub, aes(x = x, y = y, fill = min), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC", palette = "Blues", limits = c(5, 27)) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("Minimum recorded SST (", format.Date(start_dateb, "%Y"), " - ", format.Date(end_date, "%Y"),")")) 


## Plot the year of the min SST (subset HadISST range)
had_min_subset_year_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_min_sub_time, aes(x = x, y = y, fill = year), alpha=0.8) + 
  scale_fill_distiller("", palette = "YlGnBu", trans = "reverse", breaks = c(1900, 1950, 2000), limits = c(2020, 1870)) +
  guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle("Year of minimum SST") 


## Plot the month of the min SST (subset HadISST range)
had_min_subset_month_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = had_min_sub_time, aes(x = x, y = y, fill = month), alpha=0.8) + 
  scale_fill_brewer("", palette = "BrBG") +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_legend(nrow = 2)) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle("Month of minimum SST") 


## Combined min SST and year observed plot
plot_grid(had_min_subset_plot, had_min_subset_year_plot, had_min_subset_month_plot, labels = c("A", "B", "C"), ncol = 3) +
  ggsave("figures/Fig13_HadISST_minSST_subset.pdf", width = 14, height = 5)

```

**Figure 13 |** Minimum SST ($^\circ$C) recorded in the subset HadISST dataset (`r format.Date(start_date, "%Y")` - `r format.Date(end_date, "%Y")`) within each grid (**A**). The year (**B**) and month (**C**) in which each minimum SST was observed is also depicted. 


<br/>

#### Pathfinder (1981 - 2019)

```{r path min SST df}

##### Pathfinder min temp raster layer

## create raster layer of the min SST per pixel
path_brick <- brick(Pathfinder_monthly_edit_path)
raster_p_min <- min(path_brick, na.rm = TRUE)

## convert the raster of SST to a df for plotting
path_min <- as.data.frame(as(raster_p_min, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(path_min) <- c("min", "x", "y")


## convert the raster of observational year to a df for plotting
#path_min_yr <- as.data.frame(as(raster_min_yr, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
#colnames(path_min_yr) <- c("year", "x", "y")

```

```{r path min SST map, message=FALSE, warning=FALSE, fig.align='center' , fig.width=12, fig.height=6}

### Plot the min SST per pixel (Pathfinder)
path_min_plot <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = path_min, aes(x = x, y = y, fill = min), alpha=0.8, interpolate = TRUE) + 
  scale_fill_distiller("ºC", palette = "Blues", limits = c(5, 27)) +
  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
  ylab("Latitude") +
  xlab("Longitude") +
  ggtitle(paste0("Minimum recorded SST (", format.Date(start_dateb, "%Y"), " - ", format.Date(end_date, "%Y"),")"))
path_min_plot

### Plot the year of the min SST
#path_min_year_subset_plot <- ggplot() +  
#  theme_bw() +
#  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = #element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
#  #geom_raster(data = path_min_yr_sub, aes(x = x, y = y, fill = year), alpha=0.8, interpolate = TRUE) + 
#  scale_fill_distiller("ºC", palette = "Reds", trans = "reverse", limits = c(32, 26)) +
#  geom_polygon(data = land, aes(x = long, y = lat, group = group), fill = "grey70", color='grey39', lwd = 0.1) +
#  #guides(fill = guide_colorbar(reverse = TRUE, frame.colour = "black", ticks.colour = "black")) +
#  coord_sf(xlim = c(-90,-59), ylim = c(8,33)) +
#  ylab("Latitude") +
#  xlab("Longitude") +
#  ggtitle("Year of minimum recorded SST (Pathfinder)") 
#
#
### Combined min SST and year observed plot
#plot_grid(path_min_subset_plot, path_min_year_subset_plot, labels = c("A", "B")) +
#  ggsave("figures/Fig13_Pathfinder_minSST_subset.pdf", width = 14, height = 5)
#
```

**Figure 14 |** Minimum SST ($^\circ$C) recorded in the Pathfinder dataset (`r format.Date(start_date, "%Y")` - `r format.Date(end_date, "%Y")`) within each grid (**A**).

<br/><br/>

---


### Regional SST analyses

Here, I plan to work on binning the reefs into subregions (like in Muñiz-castillo *et al* 2019) for analyses of SST trends (minimum, maximum, mean, change over time) by these ecoregions. 

Another thing to note, I did not crop reefs originally with these shapefiles so I have a few on the western coast of Panama (for example) that technically do not fall within the Caribbean proper. Thoughts on if I should redo all the SST extractions (**Figures 2-5**) clipping reef locations with these shapefiles?

```{r Caribbean ecoregion shapefile modification, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

### The global marine ecoregion shapefile was read in and cropped based on the Caribbean region
region <- shapefile(ecoregion_shape_path)
regions_cropped <- crop(region, extent(-100, -55, 8, 33)) # crop for the Caribbean region only
shapefile(regions_cropped, "data/EcoRegions/Caribbean_ecoregions.shp", overwrite = TRUE) # save the new Caribbean-specific ecoregions shapefile

```

```{r assign reefs to ecoregions, message=FALSE, warning=FALSE, paged.print=FALSE}

## Read in the reef points csv and clipped Caribbean ecoregion shapefile
reef_gps <- read.csv("data/ReefData/CaribbeanReef_points.csv") # read in FULL reef locations csv
ecoreg <- read_sf("data/EcoRegions/Caribbean_ecoregions.shp") # this is used for ecoregion name list (plotting ecoregion bounds)
ecoregions2 <- readOGR('data/EcoRegions', 'Caribbean_ecoregions') # this is used for assigning ecoregion in the forloop


## Subset shapefile for the TNA province (code 12) with Bermuda removed and only the N. GoM within the WTNA province (codes 6)
carib_ecoreg <- ecoreg %>% 
  filter(PROV_CODE == 12 & ECOREGION != "Bermuda" | PROV_CODE == 6 & ECOREGION == "Northern Gulf of Mexico") 

# create unique reef id
reef_points <- reef_gps %>%
  mutate(reef_id = as.numeric(interaction(lat, lon, drop=TRUE))) %>%
  filter()

# transform points into SpatialPointsDataFrames and modify projection to be the same
coordinates(reef_points) <- c("lon", "lat")  
projection(reef_points) <- proj #
projection(ecoregions2) <- proj


## Assign reef locations to ecoregions (using forloop)

# create a list of the ecoregions (used in the forloop)
eco_list <- carib_ecoreg$ECOREGION
# make a blank dataframe to be populated from the forloop
compiled_eco_df <- data.frame('lat' = integer(),
                              'lon' = integer(),
                              'reef_id' = factor(),
                              'ecoregion' = factor())

# Create a forloop to assign reef loactions to each ecoregion and compile into single dataframe
for(e in 1:length(eco_list)) {
  ecoregion_name <- eco_list[[e]] # pull the name of ecoregion
  subset_ecoreg <- ecoregions2[ecoregions2@data$ECOREGION == ecoregion_name, ] # subset for only the desired ecoregion
  projection(subset_ecoreg) <- proj # modify the lat/lon projection to match reef points
  ecoregion_reefs <- reef_points[subset_ecoreg, ] # clip the reef points by the ecoregion bounds
  ecoregion_df <- as.data.frame(ecoregion_reefs) # transform reef points (spatial) to dataframe
  ecoregion_df$reef_id <- factor(ecoregion_df$reef_id) # make reef ID into a factor
  ecoregion_df$ecoregion <- rep(ecoregion_name, length(ecoregion_df$reef_id)) # add ecoregion name to the data
  compiled_eco_df <- rbind(compiled_eco_df, ecoregion_df) # add the most recent layer to the full dataframe
}


# Rename "Northern GoM" and "Northern GoM" to just GoM (these will be considered the same ecoregion from here on)
compiled_eco_df$ecoregion <- gsub("Northern G", "G", compiled_eco_df$ecoregion)
compiled_eco_df$ecoregion <- gsub("Southern G", "G", compiled_eco_df$ecoregion)

```

```{r reefs by ecoregion map}

### Plot the map (reefs are coloured by ecoregion with # of reefs beside region name)

## Update ecoregion labels to include number of reefs within each 
# create dataframe of just ecoregion and n
lab_df <- compiled_eco_df %>% 
  group_by(ecoregion) %>% 
  summarize(n = n())

# create new labels to display 'ECOREGION (n=NUMBER_REEFS)'
labels <- paste(lab_df$ecoregion, " (n=", lab_df$n, ")", sep = "")

# Name existing ecoregion labels based on new labels for plot 
eco_labs <- c("Bahamian" = labels[1], "Eastern Caribbean" = labels[2], "Floridian" = labels[3], "Southwestern Caribbean" = labels[7], "Western Caribbean" = labels[8], "Southern Caribbean" = labels[6], "Gulf of Mexico" = labels[5], "Greater Antilles" = labels[4])


## set colour palette and read in world shapefile
world <- ne_countries(scale = "medium", returnclass = "sf") # world shapefile
pal <- c("#FF948C", "#E48732", "#387560", "#7993CF", "#6E4096", "#5898AF", "#D9B03B", "#B8321D") # colour palette for ecoregions
pal2 <- c("#FF948C", "#E48732", "#387560", "#7993CF", "#6E4096", "#5898AF", "#6E4096", "#D9B03B", "#B8321D") # ecoregion bounds colours


## Map plot
# Note: to display the ecoregion bounds, unhash the two lines to plot the shapefiles over the map

ggplot() + 
  geom_point(data = compiled_eco_df, aes(x = lon, y = lat, colour = ecoregion), size = 0.7) +
  geom_sf(data = world) +
  #geom_sf(data = carib_ecoreg, colour = "black", aes(fill = ECOREGION), alpha = 0.1) + # for showing ecoregion bounds
  #scale_fill_manual("Ecoregion", values = pal2, labels = eco_labs) + # for showing ecoregion bounds (colours)
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), legend.text=element_text(size=12), legend.title=element_text(size=14), axis.text = element_text(size = 10)) +
  guides(colour = guide_legend(override.aes = list(size = 4))) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33)) +
  scale_colour_manual("Ecoregion", values = pal, labels = eco_labs) +
  ylab("") +
  xlab("") +
  ggsave("figures/Manuscript_figs/Fig2_ReefMap_map.pdf", width = 8, height = 3.5)

```


**Figure 14 |** Caribbean ecoregions (**A**) as established by Spalding *et al* 2007 included in this analysis and the associate reef locations (**B**). All marine ecoregion shapefiles and accompanying manuscript can be accessed [here](https://www.worldwildlife.org/publications/marine-ecoregions-of-the-world-a-bioregionalization-of-coastal-and-shelf-areas). Based on reef selection at the start of the analysis, both the Bermuda and Southern Gulf of Mexico regions have been excluded from the analysis and reefs along the western coast of Central America have been excluded with these shapes.  


```{r ecoregion SST extraction, eval=FALSE, include=FALSE}

#### SST extraction on reefs by ecoregion: this takes a while to run - can try to run remote

## Create an empty dataframe to populate while running the forloop with the following parameters:
eco_sst_df <- data.frame('date' = integer(),
                     'sst' = integer(),
                     'ecoregion' = factor())


## Create a forloop for extracting SST at reef points within each ecoregion

for(e in 1:length(eco_list)) {
  
  ## First, select reefs within specific ecoregion 
  ecoregion_name <- eco_list[[e]] # pull the name of ecoregion
  subset_ecoreg <- ecoregions2[ecoregions2@data$ECOREGION == ecoregion_name, ] # subset for only the desired ecoregion
  projection(subset_ecoreg) <- proj # modify the lat/lon projection to match reef points
  ecoregion_reefs <- reef_points[subset_ecoreg, ] # clip the reef points by the ecoregion bounds
  
  for(i in 1:raster_brick@file@nbands) {
    
    ## Then, extract SST from reef locations wihtin the current ecoregion and append to dataframe
    raster <- raster_brick[[i]] # select the layer of the rasterbrick 
    sst_vals <- raster::extract(raster, ecoregion_reefs) # extract SST at lat/lon of each reef
    # create dataframe of current layer (date) and extracted SST
    df <- data.frame('date' = raster@data@names,
                     'sst' = sst_vals)
    df$ecoregion <- rep(ecoregion_name, length(df$date)) # add a ecoregion name column
    eco_sst_df <- rbind(eco_sst_df, df) # adds current layer SST data to the full dataframe

  }
}

## Once completed, saves the resulting dataframe as both a .Rdata object and .csv
# *** Only uncomment these lines if you want to write over existing files ***
#save(eco_sst_df, file = "data/HadISST/Ecoregion_SST/HadISST_ecoregion_sst.Rdata")
#write.csv(eco_sst_df, file = "data/HadISST/Ecoregion_SST//HadISST_ecoregion_sst", row.names=FALSE)

```


<br/>

```{r ecoregion monthly SST dataframe construction}

## Load the ecoregion extracted SST data (here using Rdata, but you can use csv if smaller)
load("data/HadISST/Ecoregion_SST/HadISST_ecoregion_sst.Rdata")

# Rename "Northern GoM" and "Northern GoM" to just GoM (these will be considered the same ecoregion from here on)
eco_sst_df$ecoregion <- gsub("Northern G", "G", eco_sst_df$ecoregion)
eco_sst_df$ecoregion <- gsub("Southern G", "G", eco_sst_df$ecoregion)

ecoregion_sst <- eco_sst_df %>% 
  group_by(ecoregion, date) %>% 
  summarize(mean_sst = mean(sst, na.rm = TRUE),
            max = max(sst, na.rm = TRUE),
            min = min(sst, na.rm = TRUE),
            n = n())


ecoregion_sst <- ecoregion_sst %>% separate(date, c("year", "month", "day"), convert = TRUE) # create year, month, and day column columns
ecoregion_sst$year <- as.numeric(gsub("\\X", "", ecoregion_sst$year)) # convert the year column to numerics and remove 'X'
ecoregion_sst$month2 <- factor(ecoregion_sst$month) # make a month as a factor column for plotting  
ecoregion_sst <- subset(ecoregion_sst, year != "2020")

```

```{r playing with some SST numbers}

### Calculate simple stats of HadISST for full dataset (mean, min, max, range)

# SST of all data of whole region
Had_table2 <- eco_sst_df %>% 
 # group_by(1) %>% 
  summarise(mean = round(mean(sst, na.rm = TRUE), 2),
            min = round(min(sst, na.rm = TRUE), 2),
            max = round(max(sst, na.rm = TRUE), 2),
            range = round((max - min), 2),
            n = n())


# SST of all data by region
Had_eco_table2 <- eco_sst_df %>% 
  group_by(ecoregion) %>% 
  summarise(mean = round(mean(sst, na.rm = TRUE), 2),
            min = round(min(sst, na.rm = TRUE), 2),
            max = round(max(sst, na.rm = TRUE), 2),
            range = round((max - min), 2),
            n = n())

# SST of mean data by region
Had_table <- ecoregion_sst %>% 
  #group_by(1) %>%   
  summarise(mean = round(mean(mean_sst), 2),
            min = round(min(mean_sst), 2),
            max = round(max(mean_sst), 2),
            range = round((max - min), 2),
            n = n())




sum(Had_eco_table2$n)

### Calculate simple stats of HadISST for full dataset (mean, min, max, range)

## Wider Caribbean
# based off mean values per region per date
Had_table_sub <- ecoregion_sst %>% 
  filter(year %in% (1983:2019)) %>% 
  group_by(1) %>% 
  summarise(mean = round(mean(mean_sst), 2),
            min = round(min(mean_sst), 2),
            max = round(max(mean_sst), 2),
            range = round((max - min), 2),
            n = n())

## By ecoregion
# based off mean values per region per date
Had_eco_table_sub <- ecoregion_sst %>% 
  filter(year %in% (1983:2019)) %>% 
  group_by(ecoregion) %>% 
  summarise(mean = round(mean(mean_sst), 2),
            min = round(min(mean_sst), 2),
            max = round(max(mean_sst), 2),
            range = round((max - min), 2))



## Mean SST 1870 - 1879:
decade_first <- ecoregion_sst %>% 
  filter(year %in% (1870:1879)) %>% 
  group_by(year) %>% 
  summarise(mean = mean(mean_sst),
            min = min(mean_sst),
            max = max(mean_sst))

## Mean SST 1983 - 1992:
decade_mid <- Had_table %>% 
  filter(year %in% (1983:1992)) %>% 
  summarise(mean = mean(mean),
            min = min(min),
            max = max(max))


## Mean SST 2010 - 1019:
decade_last <- Had_table %>% 
  filter(year %in% (2010:2019)) %>% 
  summarise(mean = mean(mean),
            min = min(min),
            max = max(max))

```


```{r ecoregion monthly SST per year, fig.align='center', fig.height=10, fig.width=9}

#### Data visualization of monthly SST per year #### 

## create plots of monthly HadISST per year
# markdown plot
ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 70, hjust = 1)) +
  geom_line(data = ecoregion_sst, aes(x = month, y = mean_sst, group = year, colour = year), alpha = 0.6, size = 0.2) +
  scale_colour_gradient2("Year", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(ecoregion_sst$year), space="Lab") +
  scale_x_continuous(name = "", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  scale_y_continuous(breaks = seq(20, 32, 2)) +
  ylab('SST (°C)') +
  facet_wrap(~ecoregion, ncol = 2) +
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  ggsave("figures/Fig15_Ecoregion_SST_monthly.pdf", width = 7, height = 8)

```

**Figure 15 |** Mean SST across coral reefs within each Caribbean Ecoregion at monthly sampling event (HadISST dataset) from 1870 to 2019. Year is represented by colour of each line, changing from <span style="color: #2166ac;">blue</span> to <span style="color: #d6604d;">red</span> in more recent years.


<br/>

```{r ecoregion annual SST, fig.height=9, fig.width=9}

## Calculate summary statistic per month across years
ecoregion_sst_annual <- ecoregion_sst %>% 
  group_by(ecoregion, year) %>% 
  summarize(mean = mean(mean_sst, na.rm = TRUE),
            max = max(mean_sst, na.rm = TRUE),
            min = min(mean_sst, na.rm = TRUE),
            range = max - min,
            sd = sd(mean_sst, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se)

## Create overall mean SST per ecoregion for plotting dashed line
ecoregion_year_mean <- ecoregion_sst %>% 
  group_by(ecoregion) %>% 
  summarize(mean = round(mean(mean_sst, na.rm = TRUE), 2),
            range = round(mean((max(mean_sst, na.rm = TRUE) - min(mean_sst, na.rm = TRUE)), na.rm = TRUE), 2))

ecoregion_year_mean$lab <- paste(LETTERS[1:8])

#### Data visualization per year across months #### 

## Plot with smoothed trend
ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 30, hjust = 0.8), text = element_text(size = 14)) +
  geom_segment(data = ecoregion_year_mean, aes(y = mean, yend = mean, x = 1870, xend = 2019), colour = "grey", linetype = 2) +
  geom_ribbon(data = ecoregion_sst_annual, aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.3, linetype = 1) + 
  scale_x_continuous(name = "", breaks = seq(1880, 2019, 20)) +
  ylab('SST (°C)') +
  geom_line(data = ecoregion_sst_annual, aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.5) +
  geom_line(data = ecoregion_sst_annual, aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.5) + 
  geom_smooth(data = ecoregion_sst_annual, method = "gam", aes(x = year, y = mean), colour = "black", group = 1, size = 0.5, se = FALSE, formula = y ~ s(x, bs = "cs")) + # smoothed mean temp
  coord_cartesian(xlim = c(1870, 2019)) +
  scale_y_continuous(breaks = seq(20, 32, 2), limits = c(20, 32)) +
  facet_wrap(~ ecoregion, ncol = 2, scales = "free_y") +
  geom_text(data = ecoregion_year_mean, aes(x = -Inf, y = Inf, label = lab, group = ecoregion), fontface = "bold", size = 4.5, hjust = -0.5, vjust = 1.4) +
  ggsave("figures/Manuscript_figs/Fig4_Ecoregion_SST_trends.pdf", width = 7, height = 8)

```

**Figure 16 |** Annual mean SST (HadISST) recorded on reefs within each ecoregion (black line - *as calculated using the geom_smooth function fit with a general addative model*) and 95% confidence interval (grey ribbon). The <span style="color: #2166ac;">blue</span> line represents the annual minimum SST across sites within a specific ecoregion and the <span style="color: #d6604d;">red</span> line depicts the maximum SST across sites within an ecoregion per year. The grey horizontal dotted line represented the overall mean SST across all reefs within the Caribbean.


Main text figure 5:
```{r Figure 5 maps}

### MHW slope map

OISST_nTrend_carib <- read_rds("/Users/colleen/Dropbox/Git/MHW_spatial_correlation/OISST_nTrend_carib.Rda") # load in trend data
OISST_nTrend_carib$lon <- OISST_nTrend_carib$lon- 360 # convert lon back into -180 to 180

# add a second pval column- for the breaks used in the map_p plot below
OISST_nTrend_carib <- OISST_nTrend_carib %>% 
  mutate(pvalb = cut(p, breaks = c(0, 0.001, 0.01, 0.05, .10, .50, 1)))


## MHW slopes map
map_slope <- ggplot(OISST_nTrend_carib, aes(x = lon, y = lat)) + 
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  #geom_rect(size = 0.2, fill = NA, aes(xmin = lon - 0.1, xmax = lon + 0.1, ymin = lat - 0.1, ymax = lat + 0.1, colour = pval)) +
  geom_raster(aes(fill = slope), interpolate = FALSE, alpha = 0.9) +
  scale_fill_distiller("MHW per year", palette = "RdYlBu", limits = c((min(OISST_nTrend_carib$slope)-0.04), max(OISST_nTrend_carib$slope))) +
  #scale_color_brewer("MHW per year", palette = "RdYlBu", name = "p-value", guide = FALSE) +
  geom_polygon(data = map_base, aes(group = group), colour = "#575757", fill = "grey81") +
  theme(panel.background = element_rect(fill = "grey95")) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  ggtitle("Change in marine heat wave frequency (1981-2017)")


## MHW significance map
map_p <- ggplot(OISST_nTrend_carib, aes(x = lon, y = lat)) + 
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(aes(fill = pvalb), interpolate = FALSE) +
  scale_fill_brewer("p-value", palette = "PuBu", direction = -1, breaks = c("(0,0.001]", "(0.001,0.01]", "(0.01,0.05]", "(0.05,0.1]", "(0.1,0.5]", "(0.5,1]")) +
  geom_polygon(data = map_base, aes(group = group), colour = "#575757", fill = "grey81") +
  theme(panel.background = element_rect(fill = "grey95")) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  ggtitle("Significance of change in heat wave frequency (1981-2017)")


### Pathfinder SST slope map

## Clip Pathfinder slopes by MHW bounds
load("/Users/colleen/Dropbox/Git/CaribbeanSST/data/Pathfinder/Pathfinder_slope_UPDATE2.Rdata") # load Rdata of the modified Pathfinder raster
path_slope <- path_slope[c(2,3,1)] # just reordering the dataframe
coordinates(path_slope) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(path_slope) <- proj # modify projection to match Pathfinder
path_clipped <- path_slope[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
path_slope_clipped <- as.data.frame(path_clipped) # convert to dataframe

## Plot Pathfinder slope map
path_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(data = path_slope_clipped, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = FALSE) + 
  scale_fill_distiller("ºC per decade", palette = "RdYlBu", limits = c(-0.3, 0.4)) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  theme(panel.background = element_rect(fill = "grey95")) +
  labs(x = "", y = "") +
  ggtitle(paste0("Caribbean warming rate (1981-2019)"))


## Clip Pathfinder pvalues by MHW bounds
path_pavl <- read.csv("/Users/colleen/Dropbox/Git/CaribbeanSST/data/Pathfinder/Pathfinder_pval2.csv", header = TRUE) # read in the saved .csv of the dataframe
path_pavl <- path_pavl[c(2,3,1, 4)] # just reordering the dataframe
coordinates(path_pavl) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(path_pavl) <- proj # modify projection to match Pathfinder
pathP_clipped <- path_pavl[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
pathP_slope_clipped <- as.data.frame(pathP_clipped) # convert to dataframe

## Plot Pathfinder significance map
path_pval_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(data = pathP_slope_clipped, aes(x = x, y = y, fill = bins), alpha=0.8, interpolate = FALSE) + 
  scale_fill_manual("p-value", values = "#045a8d") +
  #scale_fill_brewer("p-value", palette = "PuBu", direction = 1) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  theme(panel.background = element_rect(fill = "grey95")) +
  labs(x = "", y = "") +
  ggtitle("Significance of Caribbean warming (1981-2019)")



### Combined plots

## Combined Figure 5:
cowplot::plot_grid(path_map, map_slope, labels = c("A", "B"), label_size = 18) +
  ggsave("/Users/colleen/Dropbox/Git/CaribbeanSST/figures/Manuscript_figs/Fig5_SST_MHW_map.pdf", width = 14.5, height = 5)

## Combined Figure 5 p values:
cowplot::plot_grid(path_pval_map, map_p, align = "hv") +
  ggsave("/Users/colleen/Dropbox/Git/CaribbeanSST/figures/SST_MHW_significance_map.pdf", width = 14.5, height = 5)

```

```{r remove really high/low slopes from Path map, eval=FALSE, include=FALSE}

test <- path_slope_clipped %>% 
  filter(sst > -0.29 & sst < 0.41)


ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = test, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = FALSE) + 
  scale_fill_distiller("ºC per decade", palette = "RdYlBu", limits = c(-0.3, 0.4)) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  theme(panel.background = element_rect(fill = "grey95")) +
  labs(x = "", y = "") +
  #geom_point(aes(-89.47917, 29.31250), colour = "purple") +# playing with some point data
  ggtitle(paste0("SST slope from 1981 to 2019 (Pathfinder)"))


```



<br/><br/>
  
---

<br/>

## <span style="color: #313695;">Session Information</span>
Last update was *`r date`*
```{r session info}

sessionInfo()

```

