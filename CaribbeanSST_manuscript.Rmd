---
title: '**A century of warming on Caribbean reefs**'
output:
 rmarkdown::html_document:
    theme: yeti
    toc: yes
    toc_float: yes
    highlight: tango
---

```{r knit options, include=FALSE}

knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE)

opts <- options(knitr.kable.NA = "")

```

```{r load libraries}

### Used packages that need to be installed to run code:
needed_packages <- c("sf", "ncdf4", "ggrepel", "raster", "viridis", "maptools", "rgdal", "openxlsx", "ggplot2", "cowplot", "tidyverse", "rnaturalearth", "xts", "RColorBrewer", "tidyr", "dplyr", "binr", "fields", "gganimate", "sp", "mgcv", "plotly", "grDevices", "foreach", "kableExtra", "splines", "gridExtra", "Hmisc", "ggpubr", "sjPlot", "broom", "modelr", "performance", "fmsb", "transformr", "gifski", "gapminder") # Specify necessary packages

not_installed <- needed_packages[!(needed_packages %in% installed.packages()[ , "Package"])] # Extract not installed packages
if(length(not_installed)) install.packages(not_installed) # Install not installed packages


# library(devtools)
# devtools::install_github("NCAR/fields")
# devtools::install_github("thomasp85/transformr") # need this for the GIFs of figures
# devtools::install_github("paleolimbot/ggspatial")

library(sf)
library(ncdf4)
library(ggrepel)
library(raster) 
library(viridis)
library(maptools)
library(rgdal)
library(openxlsx)
library(ggplot2)
library(tidyverse)
library(rnaturalearth)
library(xts)
library(RColorBrewer)
library(tidyr)
library(dplyr)
library(gifski)
library(gapminder)
library(binr)
library(fields)
library(gganimate)
library(Hmisc)
library(sp)
library(mgcv)
library(foreach)
library(plotly)
library(kableExtra)
library(grDevices)
library(splines)
library(gridExtra)
library(ggpubr)
library(sjPlot)
library(broom)
library(modelr)
library(performance)
library(fmsb)
library(transformr)

```

```{r other setup}

## set the current date
date <- Sys.Date() 


## spatial subsetting for Caribbean region
Xmin <- -100
Xmax <- -55
Ymin <- 0
Ymax <- 40


## set the projection
proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84"


## set the binning of p-values for plotting
bins <- c(-Inf, 0.0001, 0.001, 0.01, 0.05, 0.1, Inf)
bin_names <- c("< 0.0001", "0.0001 - 0.001", "0.001 - 0.01", "0.01 - 0.05", "0.05 - 0.1", "> 0.1")


## Create base map for SST maps
map_base <- ggplot2::fortify(maps::map(fill = TRUE, plot = FALSE)) %>% 
  dplyr::rename(lon = long)


## Make a shapefile of lat/lon bounds of MHW map
# make dataframe of lat/lon
bound_df <- data.frame("lon" = c(262.125, 285.125, 285.125, 302.125, 302.125, 285.125, 285.125, 276.125, 276.125, 271.125, 269.625, 262.125,262.125),
                       "lat" = c(31, 31, 25.125, 25.125, 9.125, 9.125, 7.375, 7.375, 15.875, 15.875, 17.875, 17.875, 31))
bound_df$lon <- bound_df$lon - 360 # convert lon back into -180 to 180
bound_matrix <- data.matrix(bound_df) # Transform from dataframe to a matrix
bound_poly <- Polygon(bound_matrix) # transform matrix to polygon
bound_SP <- SpatialPolygons(list(Polygons(list(bound_poly), ID = "a")), proj4string=CRS(proj)) # convert polygon to SpatialPolygon object
bound_SP_df <- as(bound_SP, "SpatialPolygonsDataFrame") # convert to SpatialPolygonsDataFrame

```

```{r setting non-git file paths}

### Since the shape and netCDF files are too large to store on GitHub, those need to be stored locally.
## Dropbox links are included to download the corresponding files. Just update the local path to each.
## The paths for the files stored on Dropbox are below:

## gshhs_f.b: coastline map shapefile
# Dropbox link: https://www.dropbox.com/s/exn3p4v2q6isvla/gshhs_f.b?dl=0
gshhs_f_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/gshhs_f.b"

## WCMC008_CoralReef2018_Py_v4.shp: global coral reef shapefiles
# Dropbox link: https://www.dropbox.com/sh/q9yn83jzx57yx9h/AACHWXkNUQ7HX4ZKqnaMzv2aa?dl=0
WCMC008_CoralReef2018_Py_v4_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/14_001_WCMC008_CoralReefs2018_v4/01_Data/WCMC008_CoralReef2018_Py_v4.shp"

## meow_ecos.shp: global ecoregion shapefiles
# Web link: https://www.worldwildlife.org/publications/marine-ecoregions-of-the-world-a-bioregionalization-of-coastal-and-shelf-areas
ecoregion_shape_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/MEOW/meow_ecos.shp"

## HadISST_sst.nc: 
# Dropbox link: https://www.dropbox.com/s/6apxz5mqz2e3i6v/HadISST_sst.nc?dl=0
HadISST_sst_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/HadISST_sst.nc"

## pathfinder_combined_monthly_data.nc: 
# Dropbox link: https://www.dropbox.com/s/qg5ybjnnd7rayub/pathfinder_combined_monthly_data.nc?dl=0
pathfinder_combined_monthly_data_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/pathfinder_combined_monthly_data.nc"

## Pathfinder_monthly_edit.nc: 
# Dropbox link: https://www.dropbox.com/s/klorzek794epfpn/PathfinderSST_monthly_edit.nc?dl=0
Pathfinder_monthly_edit_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/Pathfinder_monthly_edit_06Sep2021.nc"

## OISST_MHW_carib.Rda: 
# Dropbox link: https://www.dropbox.com/s/ztqfu2sh0da54j3/OISST_MHW_carib.Rda?dl=0
MHW_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/OISST_MHW_carib.Rda"

## mhw_carib.csv
# Dropbox link: https://www.dropbox.com/s/d2kj7531epszsua/mhw_carib.csv?dl=0
MHW_carib_path <- "/Users/colleen/Dropbox/Git/Data_Not_On_Git/CaribbeanSST_data/mhw_carib.csv"

```

<br/>

#### **Colleen B. Bove^1,2\*^, Laura Mudge^1,3^, and John F. Bruno^1^**

^1^ The Department of Biology, The University of North Carolina at Chapel Hill, Chapel Hill, North Carolina, 27599-3280 USA

^2^ The Department of Biology, Boston University, Boston, Massachusetts, 02215 USA

^3^ Integral Consulting Inc., Annapolis, Maryland 21401 USA

*Corresponding author: colleenbove@gmail.com

<br/>

#### **Abstract:**

The world’s oceans are warming at an unprecedented rate, causing dramatic changes to coastal marine systems, especially on coral reefs. We used three complementary ocean temperature databases (HadISST, Pathfinder, and OISST) to quantify change in thermal characteristics of Caribbean coral reefs over the last 150 years (1871–2020). These sea surface temperature (SST) databases included combined in situ and satellite-derived SST (HadISST, OISST), as well as satellite-only observations (Pathfinder) at multiple spatial resolutions. We also compiled a Caribbean coral reef database identifying 5,326 unique reefs across the region. We found that Caribbean reefs began warming in 1915 and have warmed on average by 0.19 °C per decade since 1994 (the calculated year that warming accelerated). Geographic variation in warming rates ranged from 0.17 °C per decade on Bahamian reefs to 0.26 °C per decade on reefs within the Southern and Eastern Caribbean ecoregions. If this linear rate of warming continues, these already threatened ecosystems would warm by an additional 1.5°C on average by 2100. We also found that marine heatwave (MHW) events are increasing in both frequency and duration across the Caribbean. Caribbean coral reefs now experience on average 5 MHW events annually, compared to 1 per year in the early 1980s, with recent events lasting on average 14 days. These changes in the thermal environment, in addition to other stressor including fishing and pollution, have caused a dramatic shift in the composition and functioning of Caribbean coral reef ecosystems.

<br/>

##### **Citation:**


*Repository DOI hosted on Zenodo* [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.4751658.svg)](https://doi.org/10.5281/zenodo.4751658)


<br/>

## Caribbean Ecoregion Coral Reefs {.tabset}

### <span style="color: #0072B2;">**Figure 1**</span>

```{r read in land shapefile, include=FALSE}

## read in the land shapefile with slightly expanded lat/lon limits
if (!rgeosStatus()) gpclibPermit()
gshhs.f.b <- gshhs_f_path
land <- getRgshhsMap(gshhs.f.b, xlim = c(-105, -40), ylim = c(-10, 40)) %>%
  fortify()

```

```{r create Caribbean reef shapefile, eval=FALSE, include=FALSE}

## read in the global coral reef shapefile 
shape <- shapefile(WCMC008_CoralReef2018_Py_v4_path)
reefs_cropped <- crop(shape, extent(Xmin, Xmax, Ymin, Ymax)) # crop for the Caribbean region only
shapefile(reefs_cropped, "data/ReefData/Caribbean_reefs.shp") # save the new Caribbean-specific reef shapefile

```

```{r assign reefs to ecoregions, message=FALSE, comment = FALSE, warning=FALSE, paged.print=FALSE}

## Read in the reef points csv and clipped Caribbean ecoregion shapefile
reef_gps <- read.csv("data/ReefData/CaribbeanReef_points.csv") # read in FULL reef locations csv
ecoreg <- sf::read_sf("data/EcoRegions/Caribbean_ecoregions.shp") # this is used for ecoregion name list (plotting ecoregion bounds)
ecoregions2 <- readOGR('data/EcoRegions', 'Caribbean_ecoregions') # this is used for assigning ecoregion in the forloop below


## Subset Caribbean shapefile for the TNA (The North Atlantic) province (code 12) with Bermuda removed and only the N. GoM within the WTNA province (codes 6)
carib_ecoreg <- ecoreg %>% 
  filter(PROV_CODE == 12 & ECOREGION != "Bermuda" | PROV_CODE == 6 & ECOREGION == "Northern Gulf of Mexico") 

# create unique reef id
reef_points <- reef_gps %>%
  mutate(reef_id = as.numeric(interaction(lat, lon, drop = TRUE))) %>%
  filter()

# transform points into SpatialPointsDataFrames and modify projection to be the same
coordinates(reef_points) <- c("lon", "lat")  
projection(reef_points) <- proj # change the projection of the reef_points dataframe
projection(ecoregions2) <- proj # change the projection of the ecoregions2 polygopn dataframe


## Assign reef locations to ecoregions (using forloop)

eco_list <- carib_ecoreg$ECOREGION # create a list of the ecoregions (used in the forloop)

# make a blank dataframe to be populated from the forloop
compiled_eco_df <- data.frame('lat' = integer(),
                              'lon' = integer(),
                              'reef_id' = factor(),
                              'ecoregion' = factor())

## Create a forloop to assign reef loactions to each ecoregion and compile into single dataframe
for(e in 1:length(eco_list)) {
  ecoregion_name <- eco_list[[e]] # pull the name of ecoregion
  subset_ecoreg <- ecoregions2[ecoregions2@data$ECOREGION == ecoregion_name, ] # subset for only the desired ecoregion
  projection(subset_ecoreg) <- proj # modify the lat/lon projection to match reef points
  ecoregion_reefs <- reef_points[subset_ecoreg, ] # clip the reef points by the ecoregion bounds
  ecoregion_df <- as.data.frame(ecoregion_reefs) # transform reef points (spatial) to dataframe
  ecoregion_df$reef_id <- factor(ecoregion_df$reef_id) # make reef ID into a factor
  ecoregion_df$ecoregion <- rep(ecoregion_name, length(ecoregion_df$reef_id)) # add ecoregion name to the data
  compiled_eco_df <- rbind(compiled_eco_df, ecoregion_df) # add the most recent layer to the full dataframe
}


# Rename "Northern GoM" and "Northern GoM" to just GoM (these will be considered the same ecoregion from here on)
compiled_eco_df$ecoregion <- gsub("Northern G", "G", compiled_eco_df$ecoregion)
compiled_eco_df$ecoregion <- gsub("Southern G", "G", compiled_eco_df$ecoregion)

```

```{r reefs by ecoregion map}

### Plot the map (reefs are coloured by ecoregion with # of reefs beside region name)

## Update ecoregion labels to include number of reefs within each 
# create dataframe of just ecoregion and n
lab_df <- compiled_eco_df %>% 
  group_by(ecoregion) %>% 
  summarise(n = n())

# create new labels to display 'ECOREGION (n=NUMBER_REEFS)'
labels <- paste(lab_df$ecoregion, " (n=", lab_df$n, ")", sep = "")

# Name existing ecoregion labels based on new labels for plot 
eco_labs <- c("Bahamian" = labels[1],
              "Eastern Caribbean" = labels[2],
              "Floridian" = labels[3],
              "Southwestern Caribbean" = labels[7],
              "Western Caribbean" = labels[8],
              "Southern Caribbean" = labels[6],
              "Gulf of Mexico" = labels[5],
              "Greater Antilles" = labels[4])


## set colour palette and read in world shapefile
world <- ne_countries(scale = "medium", returnclass = "sf") # world shapefile
pal <- c("#FF948C", "#E48732", "#387560", "#7993CF", "#6E4096", "#5898AF", "#D9B03B", "#B8321D") # colour palette for ecoregions
pal2 <- c("#FF948C", "#E48732", "#387560", "#7993CF", "#6E4096", "#5898AF", "#6E4096", "#D9B03B", "#B8321D") # ecoregion bounds colours (see note below)


## Map plot
# Note: to display the ecoregion bounds, unhash the two lines to plot the shapefiles over the map

ggplot() + 
  geom_point(data = compiled_eco_df, aes(x = lon, y = lat, colour = ecoregion), size = 0.7) +
  geom_sf(data = world) +
  #geom_sf(data = carib_ecoreg, colour = "black", aes(fill = ECOREGION), alpha = 0.1) + # for showing ecoregion bounds
  #scale_fill_manual("Ecoregion", values = pal2, labels = eco_labs) + # for showing ecoregion bounds (colours)
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), legend.text=element_text(size=12), legend.title=element_text(size=14), axis.text = element_text(size = 10)) +
  guides(colour = guide_legend(override.aes = list(size = 4))) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33)) +
  scale_colour_manual("Ecoregion", values = pal, labels = eco_labs) +
  ylab("") +
  xlab("")
  ggsave("figures/Manuscript/Fig1_ReefMap.pdf", width = 8, height = 3.5)
  ggsave("figures/Manuscript/Fig1_ReefMap.png", width = 8, height = 3.5)

```

**Fig 1. Caribbean coral reef site locations and ecoregion designation.** The colour of each reef represents the designated ecoregion and n denotes the number of unique reef locations within that ecoregion. Map layer was acquired from Natural Earth ([https://www.naturalearthdata.com](https://www.naturalearthdata.com)).

<br/>


## SST Extraction and Analysis  {.tabset}

### <span style="color: #0072B2;">**Figure 2**</span>

```{r HadISST raster extraction}

## read in the HadISST raster
had_data <- HadISST_sst_path # this is from the path defined at the start
data_brick <- brick(had_data) # read SST data as rasterbrick
data_brick <- crop(data_brick, extent(Xmin, Xmax, Ymin, Ymax)) # clip rasterbrick for Caribbean region only (see 'spatial subsetting' above)


ncdf_file <- nc_open(had_data) # open up the netCDF

nc_lats <- ncdf_file$dim$latitude$vals #other way of looking into the data structure; extracting lats (HadISST)
nc_longs <- ncdf_file$dim$lon$vals #longs here (HadISST)
nc_longs[nc_longs>180] <- nc_longs[nc_longs>180]-360 # convert lat/lon

#time handling
raw_times <- ncdf_file$dim$time$vals #times are seconds after the "start of time"
startoftime <- substr(ncdf_file$dim$time$units,1,19) #HadISST
nc_times <- as.POSIXct(gsub("days since ","",startoftime), tz="UTC", format='%Y-%m-%d') + (raw_times*60*60*24) #HadISST
nc_times <- nc_times+3600*3 #to center readings at noon - just cosmetics
nc_close(ncdf_file) #close the file

#temporal subsetting  
start_date <- "1871/01/01"
end_date <- "2020/12/31"
start_date <- as.POSIXct(start_date,tz="UTC")
end_date <- as.POSIXct(end_date,tz="UTC")

##restrict temporally - here we are not restricting temporally so not data is being removed here
Tstart_index <- min(which(difftime(nc_times,start_date)>0))
#Tend_index <- min(which(difftime(nc_times,end_date)>0))
data_brick <- data_brick[[Tstart_index:length(nc_times)]]
time <- nc_times[Tstart_index:length(nc_times)]

save(time, nc_times, file = "data/HadISST/HadISST_times.Rdata") # save the time variables for IDs for running scripts remotely


### subsetting the HadISST raster for 1981–2020 timespan for comparison with Pathfinder
start_dateb <- "1981-01-16" #"1990-01-16" 
start_dateb <- as.POSIXct(start_dateb, tz="UTC")
Tstart_indexb <- min(which(difftime(nc_times, start_dateb)>0))

data_brickb <- brick(had_data)
data_brickb <- crop(data_brickb, extent(Xmin, Xmax, Ymin, Ymax))
data_brickb <- data_brickb[[Tstart_indexb:length(nc_times)]]
timeb <- nc_times[Tstart_indexb:length(nc_times)]


### subsetting the HadISST raster for 1994–2020 timespan for rate since inflection
start_date_94 <- "1994-01-16"
start_date_94 <- as.POSIXct(start_date_94, tz="UTC")
Tstart_index_94 <- min(which(difftime(nc_times, start_date_94)>0))

data_brick_94 <- brick(had_data)
data_brick_94 <- crop(data_brick_94, extent(Xmin, Xmax, Ymin, Ymax))
data_brick_94 <- data_brick_94[[Tstart_index_94:length(nc_times)]]
time_94 <- nc_times[Tstart_index_94:length(nc_times)]

```

```{r eval=FALSE, include=FALSE}

## Looking into autocorrelation of SST per pixel for maps:
# I am testing for autocorrelation for a single pixel through the extire time series. If autocorrelation is present, I will then apply the updated model structure for all pixels in the function.

test_point <- SpatialPoints(data.frame(x = -90.29731, y = 21.4517)) # testing with a single lat/lon point
projection(test_point) <- "+proj=longlat +ellps=WGS84 +datum=WGS84"
test_raster <- raster::extract(data_brick, test_point) # extract all SST through time at this one point

# create a dataframe of the extracted values and time
test_sst <- data.frame(date = colnames(test_raster),
                       sst = test_raster[1,]) %>% 
  separate(date, c("year", "month", "day"))
test_sst$year <- as.numeric(gsub("\\X", "", test_sst$year))
test_sst$year_month <- as.numeric(paste(test_sst$year, test_sst$month, sep = "."))

sst_lm <- lm(sst ~ year_month, data = test_sst)
summary(sst_lm)
ggplot(test_sst, aes(x = year_month, y = sst)) + geom_line() + geom_smooth(method = lm, se = FALSE)


# checking for assumptions of normality: DOES NOT MEET
par(mfrow=c(2,2))
check_model(sst_lm) 
check_autocorrelation(sst_lm) # From the function: "Performs a Durbin-Watson-Test to check for autocorrelated residuals. In case of autocorrelation, robust standard errors return more accurate results for the estimates, or maybe a mixed model with error term for the cluster groups should be used."
# "Warning: Autocorrelated residuals detected (p < .001)."
plot(residuals(sst_lm))


## moving forward, need to account for autocorrelation
gls_ac <- gls(sst ~ year_month, data = test_sst, 
              correlation = corAR1(form = ~ year_month),
              na.action=na.omit)

summary(gls_ac)
par(mfrow=c(2,2))
plot(residuals(gls_ac))
plot(gls_ac)



library(MuMIn)
model.sel(sst_lm, gls_ac)

```

```{r HadISST gls map df creation, eval=FALSE, include=FALSE}

## Pull slope from the gls with a correction for autocorrelation (rate of SST change)
gls.fun <- function(x, time)
{
  if(any(is.na(x))){NA}
  else{
    gls(x ~ time, correlation = corAR1(form = ~ 1 | time), na.action=na.omit)$coefficients[2]*60*60*24 # slope here is degrees/day
  }
}

#raster_slope <- calc(data_brick, function(x)lm.fun(x, time = time))
raster_slope <- calc(data_brick, function(x) gls.fun(x, time = time)) # new slope with autocorrelation

# convert the raster to a df for plotting
raster_slope <- raster_slope*(365.25*10) # this is currently C per decade
had_slope <- as.data.frame(as(raster_slope, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_slope) <- c("sst", "x", "y")


########## Same idea, this time only being used on the 1981–2020 subset

# apply the function
raster_slopeb <- calc(data_brickb, function(x) gls.fun(x, time = timeb))

# convert the raster to a dataframe for plotting
raster_slope_sub <- raster_slopeb*(365.25*10) # this is currently C per decade
had_slope_sub <- as.data.frame(as(raster_slope_sub, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_slope_sub) <- c("sst", "x", "y")


## And again for 1994–2020 for the rate since inflection:
# apply the function
raster_slope_94 <- calc(data_brick_94, function(x) gls.fun(x, time = time_94))

# convert the raster to a dataframe for plotting
raster_slope_sub_94 <- raster_slope_94*(365.25*10) # this is currently C per decade
had_slope_sub_94 <- as.data.frame(as(raster_slope_sub_94, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_slope_sub_94) <- c("sst", "x", "y")


## Save all these rasters as R data object
save(raster_slope, had_slope, raster_slopeb, had_slope_sub, raster_slope_94, had_slope_sub_94, file = "data/HadISST/HadISST_slopes.Rdata")

# --------- *Plotting occurs down at the bottom of the markdown file* --------- #

```

```{r HadISST pvalue map df creation, eval=FALSE, include=FALSE}

## function to pull the p value per pixel of the simple lm applied to the full HadISST raster brick 
pval.fun <- function(x, time)
{
  if(any(is.na(x))){NA}
  else{
    summary(gls(x ~ time, correlation = corAR1(form = ~ 1 | time), na.action=na.omit))$tTable[2,4] # pulls the p value
  }
}
raster_pval <- calc(data_brick, function(x)pval.fun(x, time = time))

# convert the raster to a df for plotting
had_pavl <- as.data.frame(as(raster_pval, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_pavl) <- c("pval", "x", "y")
had_pavl$bins <- cut(had_pavl$pval, breaks = bins, labels = bin_names) # bins the pvales into 6 unique bins for plotting


########## Same idea, this time only being used on the 1981–2019 subset

# apply function to pull p value from each grid
raster_pvalb <- calc(data_brickb, function(x)pval.fun(x, time = timeb))

# convert the raster to a df for plotting
had_pval_sub <- as.data.frame(as(raster_pvalb, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_pval_sub) <- c("pval", "x", "y")
had_pval_sub$bins <- cut(had_pval_sub$pval, breaks = bins, labels = bin_names) # bins the pvales into 6 unique bins for plotting


## And again for 1994–2020 for the rate since inflection:
# apply the function
raster_pval_94 <- calc(data_brick_94, function(x)pval.fun(x, time = time_94))

# convert the raster to a df for plotting
had_pval_94 <- as.data.frame(as(raster_pval_94, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(had_pval_94) <- c("pval", "x", "y")
had_pval_94$bins <- cut(had_pval_94$pval, breaks = bins, labels = bin_names) # bins the pvales into 6 unique bins for plotting


## Save all these rasters as R data object
save(raster_pval, had_pavl, raster_pvalb, had_pval_sub, raster_pval_94, had_pval_94, file = "data/HadISST/HadISST_pvals.Rdata")

# --------- *Plotting occurs down at the bottom of the markdown file* --------- #

```

```{r HadISST reef SST extraction, eval=FALSE, include=FALSE}

## read in FULL reef locations csv
reef_gps <- read.csv("data/ReefData/CaribbeanReef_points.csv")

## convert sampling points to spatial points and applying projection to points
LongLat <- cbind(reef_gps$lon, reef_gps$lat) 
ReefPTS <- SpatialPoints(LongLat)
proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84"
projection(ReefPTS) <- proj

## extract data from the sst brick with the sampling points shifted
had_sst <- raster::extract(data_brick, ReefPTS)

## convert the data matrix to a final dataframe
had_sst_xts <- xts(t(had_sst), time) # t is used to transpose the matrix because xts assumes dates are along the lines, not columns
had_sst_df <- data.frame(date=index(t(had_sst_xts)), coredata(t(had_sst_xts))) # convert xts object to dataframe
had_sst_df$reef <- factor(seq(1, length(had_sst_df$date), 1)) # ID the columns to identify unique reefs
had_sst_df$date <- NULL # remove this column since it is repetitive 
had_sst_long <- gather(had_sst_df, date, sst, X1871.01.16.15.00.00:X2020.12.16.15.00.00) # convert from wide to long format

## update the dataframe for saving
had_gps <- had_sst_long %>% separate(date, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
had_gps$date <- paste(had_gps$year, had_gps$month, had_gps$day, sep = ".") # creates a full date column (XYear.Month.Day)
had_gps <- had_gps[, -c(2:7)] # remove columns for hour, minute, and seconds (we won't use these)
had_gps <- spread(had_gps, reef, sst)

## save the final dataframe (.csv or Rdata)
#write.csv(had_gps, file = "data/HadISST/HadISST_reefs_SST_update.csv") # to save file as .csv
save(had_gps, file = "data/HadISST/HadISST_reefs_SST_update.Rdata") # to save file as Rdata (I saved as Rdata since it is large)

```

```{r HadISST monthly reef SST dataframe construction}

load("data/HadISST/HadISST_reefs_SST_update.Rdata")

had_gps <- had_gps # only need to use this to make the UPDATED reef SST dataframe compatible below

## create a new dataframe of simple stats per time
had_full <- data.frame("date" = had_gps[,1],
                      "mean_temp" = rowMeans(had_gps[,-1], na.rm = TRUE),
                      "max_temp" = apply(had_gps[,-1], 1, FUN=max, na.rm = TRUE),
                      "min_temp" = apply(had_gps[,-1], 1, FUN=min, na.rm = TRUE),
                      "n" = length(had_gps[,-1]))

had_full <- had_full %>% separate(date, c("year", "month","day"), convert = TRUE) # create year, month, and day column columns
had_full$year <- as.numeric(gsub("\\X", "", had_full$year)) # convert the year column to numerics and remove 'X'
had_full$month2 <- factor(had_full$month) # make a month as a factor column for plotting

```

```{r HadISST monthly SST per year}

#### Data visualization of monthly SST per year #### 

# calculate summary statistic per month across years
HADI_month_avg <- had_full %>% 
  group_by(month) %>% 
  summarise(mean = mean(mean_temp, na.rm = TRUE),
            sd = sd(mean_temp, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se)

# make year integer for better plotting
had_full$year <- as.integer(had_full$year)

## create plots of monthly HadISST per year
had_month_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 45, hjust = 1), text = element_text(size = 14)) +
  theme(legend.position = c(0.065, 0.85), legend.key.size = unit(0.3, "cm"), legend.background = element_rect(fill = NA), plot.title = element_text(size = 12)) + # legend theme
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  geom_line(data = had_full, aes(x = month, y = mean_temp, group = year, colour = year), alpha = 0.6, size = 0.4) +
  scale_colour_gradient2("", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(had_full$year), space="Lab", breaks = seq(1870, 2020, 50)) +
  #geom_ribbon(data = HADI_month_avg, aes(x = month, ymin = lowerci, ymax = upperci), colour = "black", alpha = 0.6, linetype = 2) + 
  #geom_line(data = HADI_month_avg, aes(x = month, y = mean), colour = "black", group = 1, size = 1.5) +
  scale_x_continuous(name = "Month", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  ylab('SST (°C)') +
  ggtitle("HadISST (1871–2020)") + 
  theme(plot.title = element_text(size = 13))

```

```{r HadISST annual SST}

## Fit a GAM to the HadISST data to plot and later calculate significant slopes (Figure S2)
had_gam_df <- gather(had_gps, reef, sst, `1`:`5607`)
had_gam_df$date <- gsub("\\X", "", had_gam_df$date) # convert year to numeric and remove 'X'
had_gam_month <- had_gam_df %>% 
  separate(date, c("year", "month","day"), convert = TRUE) %>% # create year, month, and day column columns
  drop_na(sst) %>% # drop all NA values
  group_by(year, month) %>% # group by month and year t calculate mean below
  summarise(month_sst = mean(sst))

had_gam <- gamm(month_sst ~ s(year, bs = 'cr', k = 9) + s(month, bs = 'cc', k = 12), correlation = corARMA(form = ~ 1|year, p = 3), data = had_gam_month)

## Below is model checking for GAMs that should be checked out before proceeding when fitting a new GAM
#anova(had_gam$lme, had_gam150$lme)
#layout(matrix(1:4, ncol = 2))
#summary(had_gam$gam)
#gam.check(had_gam$gam)
#plot(had_gam$gam)
#qq.gam(had_gam)

had_gam_pred <- predict.gam(had_gam$gam, type = "response", se.fit = TRUE, exclude = s(month)) # predict response-level values from the GAM per year
had_predict_df <- cbind(had_gam_month, response = had_gam_pred$fit, lwr = had_gam_pred$fit - 2 * had_gam_pred$se.fit, upr = had_gam_pred$fit + 2 * had_gam_pred$se.fit) # add the predicted fit and lower/upper CIs to the GAM dataframe



#### Data visualization per year across months #### 

# calculate summary statistic per month across years
HADI_year_avg <- had_full %>% 
  group_by(year) %>% 
  summarise(mean = mean(mean_temp, na.rm = TRUE),
            max = max(mean_temp, na.rm = TRUE),
            min = min(mean_temp, na.rm = TRUE),
            sd = sd(mean_temp, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se,
         range = max - min)


## plot with smoothed trend
had_year_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size = 14)) +
  geom_hline(yintercept = mean(HADI_year_avg$mean), colour = "grey", linetype = 2) +
  geom_ribbon(data = HADI_year_avg, aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.1, linetype = 1, size = 0.2) + 
  #geom_line(data = HADI_year_avg, aes(x = year, y = mean), colour = "black", group = 1, size = 1, alpha = 0.7) + # mean sst
  scale_x_continuous(name = "Year", breaks = c(1880, 1900, 1920, 1940, 1960, 1980, 2000, 2020)) +
  ylab('SST (°C)') +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  geom_line(data = HADI_year_avg, aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.35) + # max sst
  geom_line(data = HADI_year_avg, aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.35) + # min sst
  geom_line(data = had_predict_df, aes(x = year, y = response)) + # the predicted GAM curve (modelled above)
  coord_cartesian(xlim = c(1870, 2020))
  ggsave("figures/Supplemental/Bove_SST_abstract_image.png", width = 6, height = 3.75)

```

```{r HadISST combined figure, fig.align='center', fig.width=6, fig.height=7.5}

# Saves the manuscript version of the HadISST historic SST
ggarrange(had_month_plot, had_year_plot, ncol = 1, labels = c("A", "B"), align = "hv")
  ggsave("figures/Manuscript/Fig2_SST_trends.pdf", width = 6, height = 7.5)

```

**Fig 2. Historic SST trend on Caribbean coral reefs (1871–2020).** Long-term SST records (HadISST) on Caribbean coral reefs depicting **A**) mean monthly SST each year (represented by line colour: blue to red) and **B**) GAM smoothed annual mean SST time (black line), annual maximum (red line), and annual minimum (blue line) SST. The grey dashed horizontal line denotes the overall mean SST for all sites over the entire period (27.3 °C) and the grey ribbon represents the 95% confidence interval around the annual mean SST through time.

<br/>


### <span style="color: #0072B2;">**Figure 3**</span>

```{r HadISST ecoregion SST extraction - REMOTE, eval=FALSE, include=FALSE}

# ***NOTE***
####--- this portion of the script was run on a high performance computing cluster because of the long runtime 
####--- see separate R script (SSTExtraction_ReefGPS.R) for instructions (located in the code folder)
####--- the script can be put on a cluster with the HadISST netCDF (HadISST_sst.nc) to run


##########################################

### Extract SST using the ecoregion classifications and reef points

## Create an empty dataframe to populate while running the forloop with the following parameters:
eco_df <- data.frame('date' = integer(),
                     'sst' = integer(),
                     'ecoregion' = factor())

eco_sst_df <- data.frame('date' = integer(),
                         'sst' = integer(),
                         'ecoregion' = factor())


#### Run the forloop in parallel (if able):

## Read in the HadISST netCDF and clip based on Caribbean bounds
data_brick <- brick("data/HadISST/HadISST_sst.nc") # read SST data as rasterbrick
raster_brick <- crop(data_brick, extent(Xmin, Xmax, Ymin, Ymax)) # clip rasterbrick for Caribbean region only (see 'spatial subsetting' above)
layers <- raster_brick@data@nlayers

for(e in 1:length(eco_list)) {
 e = 1
  ## First, select reefs within specific ecoregion 
  ecoregion_name <- eco_list[[e]] # pull the name of ecoregion
  subset_ecoreg <- ecoregions2[ecoregions2@data$ECOREGION == ecoregion_name, ] # subset for only the desired ecoregion
  projection(subset_ecoreg) <- proj # modify the lat/lon projection to match reef points
  ecoregion_reefs <- reef_points[subset_ecoreg, ] # clip the reef points by the ecoregion bounds
  
  output <- foreach(i = 1:layers, .combine = "rbind", .packages = c("raster", "rgdal", "sf", "ncdf4", "tidyverse")) %dopar% {
    
    ## Read in the netCDF and clip based on Caribbean bounds
    data_brick <- brick("data/HadISST/HadISST_sst.nc") # read SST data as rasterbrick
    #data_brick <- brick(had_data) # read SST data as rasterbrick (for running on local computer)
    raster_brick <- crop(data_brick, extent(Xmin, Xmax, Ymin, Ymax)) # clip rasterbrick for Caribbean region only (see 'spatial subsetting' above)
    
    ## Then, extract SST from reef locations wihtin the current ecoregion and append to dataframe
    raster <- raster_brick[[i]] # select the layer of the rasterbrick 
    sst_vals <- raster::extract(raster, ecoregion_reefs) # extract SST at lat/lon of each reef
    # create dataframe of current layer (date) and extracted SST
    df <- data.frame('date' = raster@data@names,
                     'sst' = sst_vals)
    df$ecoregion <- rep(ecoregion_name, length(df$date)) # add a ecoregion name column
    eco_df <- rbind(eco_df, df) # adds current layer SST data to the full dataframe
    
    return(eco_df)
  }
  eco_sst_df <- rbind(eco_sst_df, output)
}



## Once completed, saves the resulting dataframe as both a .Rdata object and .csv
# *** Only uncomment these lines if you want to write over existing files ***
#save(eco_sst_df, file = "data/HadISST/Ecoregion_SST/HadISST_ecoregion_sst.Rdata")
#write.csv(eco_sst_df, file = "data/HadISST/Ecoregion_SST/HadISST_ecoregion_sst", row.names=FALSE)

```

```{r HadISST ecoregion monthly SST dataframe construction}

## Load the ecoregion extracted SST data (here using Rdata, but you can use csv if smaller)
load("data/HadISST/HadISST_ecoregion_sst.Rdata")

# Rename "Northern GoM" and "Northern GoM" to just GoM (these will be considered the same ecoregion from here on)
eco_sst_df$ecoregion <- gsub("Northern G", "G", eco_sst_df$ecoregion)
eco_sst_df$ecoregion <- gsub("Southern G", "G", eco_sst_df$ecoregion)

ecoregion_sst <- eco_sst_df %>% 
  group_by(ecoregion, date) %>% 
  summarise(mean_sst = mean(sst, na.rm = TRUE),
            max = max(sst, na.rm = TRUE),
            min = min(sst, na.rm = TRUE),
            n = n())


ecoregion_sst <- ecoregion_sst %>% separate(date, c("year", "month", "day"), convert = TRUE) # create year, month, and day column columns
ecoregion_sst$year <- as.numeric(gsub("\\X", "", ecoregion_sst$year)) # convert the year column to numerics and remove 'X'
ecoregion_sst$month2 <- factor(ecoregion_sst$month) # make a month as a factor column for plotting  

```

```{r HadISST ecoregion monthly SST per year, eval=FALSE, fig.align='center', fig.height=10, fig.width=9, include=FALSE}

#### Data visualization of monthly SST per year #### 

## create plots of monthly HadISST per year
# markdown plot
ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 70, hjust = 1)) +
  geom_line(data = ecoregion_sst, aes(x = month, y = mean_sst, group = year, colour = year), alpha = 0.6, size = 0.2) +
  scale_colour_gradient2("Year", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(ecoregion_sst$year), space="Lab") +
  scale_x_continuous(name = "", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  scale_y_continuous(breaks = seq(20, 32, 2)) +
  ylab('SST (°C)') +
  facet_wrap(~ecoregion, ncol = 2) +
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black"))

```

```{r HadISST ecoregion annual SST, fig.height=9, fig.width=9}

## Calculate summary statistic per month across years
ecoregion_sst_annual <- ecoregion_sst %>% 
  group_by(ecoregion, year) %>% 
  summarise(mean = mean(mean_sst, na.rm = TRUE),
            max = max(mean_sst, na.rm = TRUE),
            min = min(mean_sst, na.rm = TRUE),
            range = max - min,
            sd = sd(mean_sst, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se)

## Create overall mean SST per ecoregion for plotting dashed line
ecoregion_year_mean <- ecoregion_sst %>% 
  group_by(ecoregion) %>% 
  summarise(mean = round(mean(mean_sst, na.rm = TRUE), 2),
            range = round(mean((max(mean_sst, na.rm = TRUE) - min(mean_sst, na.rm = TRUE)), na.rm = TRUE), 2))

ecoregion_year_mean$lab <- paste(LETTERS[1:8])

#### Data visualization per year across months #### 

## Plot with smoothed trend
ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 30, hjust = 0.8), text = element_text(size = 14)) +
  geom_segment(data = ecoregion_year_mean, aes(y = mean, yend = mean, x = 1870, xend = 2020), colour = "darkgrey", linetype = 2) +
  geom_ribbon(data = ecoregion_sst_annual, aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.1, linetype = 1, size = 0.2) + 
  scale_x_continuous(name = "", breaks = seq(1880, 2020, 20)) +
  ylab('SST (°C)') +
  geom_line(data = ecoregion_sst_annual, aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.35) +
  geom_line(data = ecoregion_sst_annual, aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.35) + 
  geom_smooth(data = ecoregion_sst_annual, method = "gam", aes(x = year, y = mean), colour = "black", alpha = 0.9, group = 1, size = 0.4, se = FALSE, formula = y ~ s(x, bs = "cs")) + # smoothed mean temp
  coord_cartesian(xlim = c(1870, 2020)) +
  scale_y_continuous(breaks = seq(20, 32, 2), limits = c(20, 32)) +
  facet_wrap(~ ecoregion, ncol = 2, scales = "free_y") +
  geom_text(data = ecoregion_year_mean, aes(x = -Inf, y = Inf, label = lab, group = ecoregion), fontface = "bold", size = 4.5, hjust = -0.5, vjust = 1.4)
  ggsave("figures/Manuscript/Fig3_Ecoregion_SST_trends.pdf", width = 7, height = 8)

```

**Fig 3. Historic SST trends on coral reefs within ecoregions (1871–2020).** Long-term SST records (HadISST) on Caribbean coral reefs separated by ecoregion depicting GAM smoothed annual mean SST time (black line), annual maximum (red line), and annual minimum (blue line) SST. The grey dashed horizontal line denotes the mean SST over the entire period and the grey ribbon represents the 95% confidence interval around the true annual SST mean for each ecoregion.

<br/>


### <span style="color: #0072B2;">**Figure 6**</span>

```{r climate stripes, fig.width = 6, fig.height = 3.3}

had_annual_df <- had_full %>% 
  group_by(year) %>% 
  summarise(mean = mean(mean_temp, na.rm = TRUE))


stripes <- ggplot(data = had_annual_df, aes(x = year, y = 1, fill = mean, colour = mean)) +
  theme_pubr() +
  theme(legend.position = "none", axis.line = element_blank(), axis.ticks = element_blank(), axis.text.y = element_blank(), axis.title = element_blank()) +
  theme(axis.text.x = element_text(vjust = 5)) +
  geom_bar(stat = "identity") +
  scale_fill_gradient2(low = "#2166ac", high = "#b2182b", mid = "#dedede", midpoint = 27.3) +
  scale_colour_gradient2(low = "#2166ac", high = "#b2182b", mid = "#dedede", midpoint = 27.3) +
  scale_x_continuous(limits = c(1870, 2020), breaks = seq(1870, 2020, by = 30)) +
  ggtitle("Caribbean coral reef temperatures 1870-2020")


# Saves the manuscript version of the Pathfinder historic SST
ggplotly(stripes)
  ggsave("figures/Manuscript/Fig6_ClimateStripes.pdf", width = 6, height = 3.3)
  ggsave("figures/Manuscript/Fig6_ClimateStripes.png", width = 6, height = 3.3)

```

**Fig 6.** Climate stripe diagram depicting the mean annual temperature recorded on Caribbean coral reefs based on the HadISST database. Warmer temperatures are depicted in red (maximum annual SST of 28.0) and cooler annual temperatures are in blue (minimum annual SST of 26.6) (figure inspired by Professor Ed Hawkins [Show Your Stripes](https://showyourstripes.info/)).

<br/>

### Figure S1

```{r calculate HadISST GAM slope significance}

## Source the required functions written by Gavin Simpson for calculating significant slopes based on first derivative of GAM
# This code is modified from his tutorials here: https://fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
source('code/GSimpsonFunctions.R') 

## Derivative calculation (using the HadISST GAM modelled above (had_gam))
m_terms <- attr(terms(had_gam$gam), "term.labels") # pull out the model term labels (here, "year" and "month")
newD <- data.frame(model.frame(had_gam$gam)[, m_terms, drop = FALSE]) # creates new dataframe of the terms identified above
X0 <- predict(had_gam$gam, newD, type = "lpmatrix") # predict returning matrix of linear predictors from model derivatives
eps <- 1e-7 # set finite difference interval
newD$year <- newD$year + eps ## shift the evaluation mesh
X1 <- predict(had_gam$gam, newD, type = "lpmatrix")
Xp <- (X1 - X0) / eps
t_labs <- attr(had_gam$gam$terms, "term.labels") # number of smooth terms
nt <- length(t_labs)

## forloop to run through smooth terms and calculate derivative and SE
lD <- vector(mode = "list", length = nt) # create empty list to hold the derivatives
names(lD) <- t_labs # rename with the smoothing terms
for(i in seq_len(nt)) {
  i = 1
  Xi <- Xp * 0
  want <- grep(t_labs[i], colnames(X1))
  Xi[, want] <- Xp[, want]
  df <- Xi %*% coef(had_gam$gam)
  df.sd <- rowSums(Xi %*% had_gam$gam$Vp * Xi)^.5
  lD[[i]] <- list(deriv = df, se.deriv = df.sd)
}

## Modify the lD object created above
class(lD) <- "Deriv" # change the class to 'Deriv'
lD$gamModel <- had_gam$gam # add GAM
lD$eps <- eps # add eps (defined above)
newD$year <- newD$year - eps # modify year by eps
lD$eval <- newD # add modified year

# confint and signifD are sourced from GSimpson_functions.R
# signifD is commented out and regions of significance are calculated manually to allow plotting +/- intervals in different colors 
CI <- confint(lD, term = 'year', alpha = 0.05) # calculate upper and lower 95% CI (alpha = 0.05) of term "year"
sig <- data.frame(up = CI$year$upper, low = CI$year$lower, seq = seq(1:length(CI$year$upper))) # create a dataframe of the upper/lower CI
incr <- sig[sig$low > 0,] # dataframe with all rows with CI greater than 0 (significant increase)
decr <- sig[sig$up < 0,] # dataframe with all rows with CI lower than 0 (significant decline)
had_predict_df$incr <- had_predict_df$decr <- NA # adds columns with NAs for 'incr' and 'decr' to the predicted dataframe
had_predict_df$incr[incr$seq] <- 1 # replaces NA with 1 in 'incr' column when CI is significantly increasing
had_predict_df$decr[decr$seq] <- 1 # replaces NA with 1 in 'decr' column when CI is significantly decreasing


## Create a dataframe of significant increasing or decreasing slope values to overlay GAM curve
had_gam_slope <- data.frame("year" = integer(),
                            "value" = numeric(),
                            "type" = character())

for(i in c("incr")) {
  change_yrs <- data.frame(year = had_predict_df$year[which(had_predict_df[i] == 1)],
                       y = as.numeric(had_predict_df$response[which(had_predict_df[i] == 1)]))
  change_yrs2 <- change_yrs[!duplicated(change_yrs$year),]
  change_slope <- expand.grid(min(change_yrs2$year):max(change_yrs2$year))
  change_slope$val <- apply(change_slope, 1, function(x) if (nrow(subset(change_yrs2, year == x[1]))) subset(change_yrs2, year == x[1])$y else NA)
  change_slope$type <- rep(i, nrow(change_slope))
  names(change_slope) <- c("year", "value", "type")
  had_gam_slope <- rbind(had_gam_slope, change_slope)
}

```

```{r plot the HadISST GAM with sig slopes}

ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size = 14), legend.position = "none") +
  geom_hline(yintercept = mean(HADI_year_avg$mean), colour = "grey", linetype = 2) +
  geom_ribbon(data = HADI_year_avg, aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.1, linetype = 1, size = 0.2) + 
  scale_x_continuous(name = "Year", breaks = c(1880, 1900, 1920, 1940, 1960, 1980, 2000, 2020)) +
  ylab('SST (°C)') +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  geom_line(data = HADI_year_avg, aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.35) + # max sst
  geom_line(data = HADI_year_avg, aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.35) + # min sst
  geom_rect(aes(ymin = -Inf, ymax = Inf, xmin = 1994, xmax = Inf), colour = 'black', fill = "#fee090", alpha = 0.2) +
  geom_rect(aes(ymin = -Inf, ymax = Inf, xmin = 1915, xmax = 1945), colour = 'black', fill = "#fee090", alpha = 0.2) +  
  geom_text(aes(x = 1999, y = 23.9, label = "1994"), size = 3) +
  geom_text(aes(x = 1920, y = 23.9, label = "1915"), size = 3) +
  geom_line(data = had_predict_df, aes(x=year, y=response), lwd = 0.75) +
  geom_line(data = had_gam_slope, aes(x = year, y = value, colour = type), lwd = 0.75) +
  scale_colour_manual(values = c( "#d73027")) +
  coord_cartesian(xlim = c(1870, 2020))
  ggsave("figures/Supplemental/FigS1_HadISST_GAM_slopes.pdf", width = 6, height = 3.75) 
  ggsave("figures/Supplemental/FigS1_HadISST_GAM_slopes.png", width = 6, height = 3.75)

```

**Supplemental Figure 1.** Historic SST trend on Caribbean coral reefs (1871–2020). Long-term SST records (HadISST) on Caribbean coral reefs depicting significant changes in warming rate based on the first derivative of the GAM slope. The GAM smoothed annual mean SST time is represented by the black line with significantly warming (red) identified over the curve. The most recent significant warming event began in 1987 and is highlighted in the yellow box. The annual maximum (red line) and annual minimum (blue line) SST are also depicted, along with the overall mean SST for all sites over the entire period (27.3 °C; grey dashed line). The grey ribbon represents the 95% confidence interval around the true annual SST mean through time.


```{r ecoregion GAM slope significance}

### This is modified from above to determine the inflection point per ecoregion

# drop NA's and make ecoregion a factor for GAM using the HadISST data per ecoregion
eco_gam_month <- ecoregion_sst %>% 
  drop_na(mean_sst) %>% # drop all NA values
  mutate(ecoregion = factor(ecoregion)) 

# dataframe to populate with slopes
eco_gam_slope <- data.frame("year" = integer(),
                            "value" = numeric(),
                            "ecoregion" = factor())

# dataframe to populate with predicted values
eco_predict_df_final <- data.frame(year = integer(),
                             month = integer(),
                             ecoregion = factor(),
                             mean_sst = numeric(),
                             response = numeric(),
                             lwr = numeric(),
                             upr = numeric(),
                             incr = numeric())

## forloop to model GAM per ecoregion and then calculate significant increases in slope (warming)
for(e in levels(eco_gam_month$ecoregion)) {
  subset_ecoreg <- eco_gam_month[eco_gam_month$ecoregion == e,]
  eco_mod <- gam(mean_sst ~ s(year, bs = 'cr', k = 9) + s(month, bs = 'cc', k = 12),correlation = corARMA(form = ~ 1|year, p = 3), data = subset_ecoreg)
  eco_gam_pred <- predict.gam(eco_mod, type = "response", se.fit = TRUE, exclude = s(month))
  eco_predict_df <- cbind(subset_ecoreg, response = eco_gam_pred$fit, lwr = eco_gam_pred$fit - 2 * eco_gam_pred$se.fit, upr = eco_gam_pred$fit + 2 * eco_gam_pred$se.fit)
  
  ## Derivative calculation (using the ecoISST GAM eco_modelled above (eco_mod))
  m_terms <- attr(terms(eco_mod), "term.labels") # pull out the eco_model term labels (here, "year" and "month")
  newD <- data.frame(model.frame(eco_mod)[, m_terms, drop = FALSE]) # creates new dataframe of the terms identified above
  X0 <- predict(eco_mod,newD, type = "lpmatrix") # predict returning matrix of linear predictors from eco_model derivatives
  eps <- 1e-7 # set finite difference interval
  newD$year <- newD$year + eps ## shift the evaluation mesh
  X1 <- predict(eco_mod, newD, type = "lpmatrix")
  Xp <- (X1 - X0) / eps
  t_labs <- attr(eco_mod$terms, "term.labels") # number of smooth terms
  nt <- length(t_labs)
  
  ## forloop to run through smooth terms and calculate derivative and SE
  lD <- vector(mode = "list", length = nt) # create empty list to hold the derivatives
  names(lD) <- t_labs # rename with the smoothing terms
  for(i in seq_len(nt)) {
    Xi <- Xp * 0
    want <- grep(t_labs[i], colnames(X1))
    Xi[, want] <- Xp[, want]
    df <- Xi %*% coef(eco_mod)
    df.sd <- rowSums(Xi %*% eco_mod$Vp * Xi)^.5
    lD[[i]] <- list(deriv = df, se.deriv = df.sd)
  }
  
  ## eco_modify the lD object created above
  class(lD) <- "Deriv" # change the class to 'Deriv'
  lD$gamModel <- eco_mod # add GAM
  lD$eps <- eps # add eps (defined above)
  newD$year <- newD$year - eps # eco_modify year by eps
  lD$eval <- newD # add eco_modified year
  
  # confint and signifD are sourced from GSimpson_functions.R
  # signifD is commented out and regions of significance are calculated manually to allow plotting +/- intervals in different colors 
  CI <- confint(lD, term = 'year', alpha = 0.05) # calculate upper and lower 95% CI (alpha = 0.05) of term "year"
  sig <- data.frame(up = CI$year$upper, low = CI$year$lower, seq = seq(1:length(CI$year$upper))) # create a dataframe of the upper/lower CI
  incr <- sig[sig$low > 0,] # dataframe with all rows with CI greater than 0 (significant increase)
  eco_predict_df$incr <- NA # adds columns with NAs for 'incr' and 'decr' to the predicted dataframe
  eco_predict_df$incr[incr$seq] <- 1 # replaces NA with 1 in 'incr' column when CI is significantly increasing
  
  ## Create a dataframe of significant increasing or decreasing slope values to overlay GAM curve
  change_yrs <- data.frame(year = eco_predict_df$year[which(eco_predict_df$incr == 1)],
                           y = as.numeric(eco_predict_df$response[which(eco_predict_df$incr == 1)]))
  change_yrs2 <- change_yrs[!duplicated(change_yrs$year),]
  change_slope <- expand.grid(min(change_yrs2$year):max(change_yrs2$year))
  change_slope$val <- apply(change_slope, 1, function(x) if (nrow(subset(change_yrs2, year == x[1]))) subset(change_yrs2, year == x[1])$y else NA)
  change_slope$ecoregion <- rep(e, nrow(change_slope))
  names(change_slope) <- c("year", "value", "ecoregion")
  
  eco_gam_slope <- rbind(eco_gam_slope, change_slope)
  eco_predict_df_final <- rbind(eco_predict_df_final, data.frame(eco_predict_df))
  
}


## Plots each individual GAM per ecoregion with highlighted regions of significant warming as calculated above. This plot is not in the manuscipt at present.
ecoregion_sig_slope_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 30, hjust = 0.8), text = element_text(size = 14)) +
  geom_segment(data = ecoregion_year_mean, aes(y = mean, yend = mean, x = 1870, xend = 2020), colour = "darkgrey", linetype = 2) +
  geom_ribbon(data = ecoregion_sst_annual, aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.1, linetype = 1, size = 0.2) + 
  scale_x_continuous(name = "", breaks = seq(1880, 2020, 20)) +
  ylab('SST (°C)') +
  geom_line(data = ecoregion_sst_annual, aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.35) +
  geom_line(data = ecoregion_sst_annual, aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.35) + 
  coord_cartesian(xlim = c(1870, 2020)) +
  scale_y_continuous(breaks = seq(20, 32, 2), limits = c(20, 32)) +
  facet_wrap(~ ecoregion, ncol = 2, scales = "free_y") +
  geom_line(data = eco_predict_df_final, aes(x=year, y=response), colour = "black") +  
  geom_line(data = eco_gam_slope, aes(x = year, y = value), lwd = 0.75, colour = "#d73027") +
  geom_text(data = ecoregion_year_mean, aes(x = -Inf, y = Inf, label = lab, group = ecoregion), fontface = "bold", size = 4.5, hjust = -0.5, vjust = 1.4)

```


<br/>


### Figure S2

```{r Pathfinder raster and times}

## read in the Pathfinder raster
path_data <- pathfinder_combined_monthly_data_path
data_brick2 <- brick(path_data) # read SST data as rasterbrick
data_brick2 <- crop(data_brick2,extent(Xmin,Xmax,Ymin,Ymax)) # clip rasterbrick for Caribbean region only (see 'spatial subsetting' above)


ncdf_file <- nc_open(path_data)
#ncdf_file

nc_lats <- ncdf_file$dim$lat$vals #other way of looking into the data structure; extracting lats
nc_longs <- ncdf_file$dim$lon$vals #longs here
nc_longs[nc_longs>180] <- nc_longs[nc_longs>180]-360

#time handling
raw_times <- ncdf_file$dim$time$vals # times are seconds after the "start of time"
startoftime <- ncdf_file$dim$time$units # here's what they consider the start of time
nc_times<-as.POSIXct(raw_times, tz="UTC", gsub("seconds since ","", startoftime))
nc_times <- nc_times+3600*3 # to center readings at noon - just cosmetics
nc_close(ncdf_file) # close the file

# temporal subsetting  
start_date2 <- "1981-09-15"
end_date2 <- "2019-12-16"
#end_date2 <- "1982-08-16" # using this one for just a subset of 12 months
start_date2 <- as.POSIXct(start_date2, tz="UTC")
end_date2 <- as.POSIXct(end_date2, tz="UTC")
    
# restrict temporally
Tstart_index2 <- min(which(difftime(nc_times,start_date2)>0))
Tend_index2 <- min(which(difftime(nc_times,end_date2)>0))
data_brick2 <- data_brick2[[Tstart_index2:Tend_index2]]
time <- nc_times[Tstart_index2:Tend_index2]

# save time component
save(time, nc_times, file = "data/Pathfinder/Pathfinder_times.Rdata")# save the time variables for IDs for running scripts remotely

```

```{r eval=FALSE, include=FALSE}

## Looking into autocorrelation of SST per pixel for maps:
# I am testing for autocorrelation for a single pixel through the extire time series. If autocorrelation is present, I will then apply the updated model structure for all pixels in the function.

test_point <- SpatialPoints(data.frame(x = c(-90.29731, -90.5, -89.8), y = c(21.4517, 23, 22))) # testing with a single lat/lon point
projection(test_point) <- "+proj=longlat +ellps=WGS84 +datum=WGS84"
test_raster <- raster::extract(data_brick2b, test_point) # extract all SST through time at this one point
plot(raster(test_raster))
xyFromCell(data_brick2b, 1)

# create a dataframe of the extracted values and time
test_sst <- data.frame(date = colnames(test_raster),
                       sst = test_raster[1,]) %>% 
  separate(date, c("text", "layer"))
test_sst$layer <- as.numeric(test_sst$layer)

sst_lm <- lm(sst ~ layer, data = test_sst)
summary(sst_lm)
ggplot(test_sst, aes(x = layer, y = sst)) + geom_line() + geom_smooth(method = lm, se = FALSE)


# checking for assumptions of normality: DOES NOT MEET
par(mfrow=c(2,2))
check_model(sst_lm) 
check_autocorrelation(sst_lm) # From the function: "Performs a Durbin-Watson-Test to check for autocorrelated residuals. In case of autocorrelation, robust standard errors return more accurate results for the estimates, or maybe a mixed model with error term for the cluster groups should be used."
# "Warning: Autocorrelated residuals detected (p < .001)."
plot(residuals(sst_lm))


## moving forward, need to account for autocorrelation
gls_ac <- gls(sst ~ layer, data = test_sst, 
              correlation = corAR1(form = ~ layer),
              na.action=na.omit)

summary(gls_ac)


library(MuMIn)
model.sel(sst_lm, gls_ac)

```

```{r Pathfinder raster edit and slope calculation - REMOTE, eval=FALSE, include=FALSE}

# ***NOTE***
####--- this portion of the script was run on a high performance computing cluster because of the long runtime 
####--- see separate R script (Pathfinder_RasterCalculations.R) for instructions (located in the code folder)
####--- the script can be put on a cluster with the Pathfinder netCDF (pathfinder_combined_monthly_data.nc) to run


##########################################

## Remove NAs and convert to C
KtoC <- function(x){round((x - 273.15), 2)} # converts the raster from Kelvin to Celsius
NAset <- function(x){x[x < -54] <- NA; return(x)} # Pathfinder uses the value -54 (K) to denote missing data and this function replaces that with NA
data_brick2 <- calc(data_brick2, NAset) # apply the NA function written above to raster
data_brick2b <- calc(data_brick2, KtoC) # apply the Kelvin function written above to raster

load("data/Pathfinder/Pathfinder_times.Rdata") # load the Pathfinder raster times


### Slope Calculation
## Calculate slope of temperature change across time for each pixel
# gls function applied to the raster brick to calculate the slope of temperature change over timescale of raster (with account of temporal autocorrelation)

gls.fun2 <- function(x, time, na.rm=TRUE, ...){
  if((sum(!is.na(x))) < 3){
    return(NA)}
  else {
    nlme::gls(x ~ time, correlation = corAR1(form = ~ 1 | time), na.action = na.omit, control = list(singular.ok = TRUE))$coefficients[2]*60*60*24 # slope here is degrees/day
  }}


raster_slope2 <- calc(data_brick2, fun = function(x){gls.fun2(x, time = time)}) 

## Create dataframe from calculated slope raster in C per decade for plotting
raster_slope2 <- raster_slope2*(365.25*10) # this is currently C per decade
path_slope <- as.data.frame(as(raster_slope2, "SpatialPixelsDataFrame")) # convert to a raster to da$
colnames(path_slope) <- c("sst", "x", "y")

## Save the slope raster:
save(path_slope, file = "Pathfinder_slope.Rdata")
write.csv(path_slope, file = "Pathfinder_slope.csv", row.names=FALSE)


# --------- *Plotting occurs down at the bottom of the markdown file* --------- #

```

```{r Pathfinder pvalue map df creation - REMOTE, eval=FALSE, include=FALSE}

# ***NOTE***
####--- This does take a while (~10 minutes), however it can be run locally.
####--- see separate R script (Pathfinder_RasterCalculations.R) for instructions (located in the code folder)
####--- the script can be put on a cluster with the Pathfinder netCDF (pathfinder_combined_monthly_data.nc) to run


##########################################

## load in the edited pathfinder raster
path_brick <- brick(Pathfinder_monthly_edit_path)
load("data/Pathfinder/Pathfinder_times.Rdata") # also load the time layer


### P value Calculation
## function to pull the p value per pixel of gls function applied to the raster brick to calculate the slope of temperature change over timescale of raster (with account of temporal autocorrelation)
pval.fun <- function(x, time, na.rm=TRUE, ...){
  if((sum(!is.na(x))) < 3){
    return(NA)}
  else{
    summary(nlme::gls(x ~ time, correlation = corAR1(form = ~ 1 | time), na.action = na.omit, control = list(singular.ok = TRUE)))$tTable[2,4] # pulls the p value
  }
}

## function to pull the p value per pixel of the simple lm applied to the full Pathfinder raster brick 
raster_pval2 <- raster::calc(data_brick2, function(x){pval.fun(x, time = time)})

## convert the raster to a df for plotting
path_pval <- as.data.frame(as(raster_pval2, "SpatialPixelsDataFrame")) # convert to a raster to dataframe
colnames(path_pval) <- c("pval", "x", "y")
path_pval$bins <- cut(path_pval$pval, breaks = bins, labels = bin_names) # bins the pvales into 6 unique bins for plotting


save(path_pval, file = "Pathfinder_pval.Rdata")
write.csv(path_pval, file = "Pathfinder_pval.csv", row.names=FALSE)

# --------- *Plotting occurs down at the bottom of the markdown file* --------- #

```

```{r Pathfinder GPS extraction, eval=FALSE, include=FALSE}

# This takes a while to run, however, it was run locally.

load("data/Pathfinder/Pathfinder_times.Rdata")

## read in the Pathfinder raster
path_data <- Pathfinder_monthly_edit_path
data_brick2 <- brick(path_data) # read SST data as rasterbrick
data_brick2 <- crop(data_brick2,extent(Xmin,Xmax,Ymin,Ymax)) # clip rasterbrick for Caribbean region only (see 'spatial subsetting' above)

reef_gps <- read.csv("data/ReefData/CaribbeanReef_points.csv") # read in FULL reef locations csv

## convert sampling points to spatial points and applying projection to points
LongLat <- cbind(reef_gps$lon, reef_gps$lat) 
ReefPTS <- SpatialPoints(LongLat)
proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84"
projection(ReefPTS) <- proj


## extract data from the sst brick with the sampling points shifted
path_sst <- raster::extract(data_brick2, ReefPTS)   # path_sst <- raster::extract(data_brick2, ReefPTS_shifted)


## convert the data matrix to a final dataframe
path_sst_xts <- xts(t(path_sst), time) # t is used to transpose the matrix because xts assumes dates are along the lines, not columns
path_sst_df <- data.frame(date=index(t(path_sst_xts)), coredata(t(path_sst_xts))) # convert xts object to dataframe
path_sst_df$reef <- factor(seq(1, length(path_sst_df$date), 1)) # ID the columns to identify unique reefs
path_sst_df$date <- NULL # remove this column since it is repetitive 
path_sst_long <- gather(path_sst_df, date, sst, X1981.09.15.17.34.40:X2019.12.16.11.45.55) # convert from wide to long format

## update the dataframe for saving
path_gps <- path_sst_long %>% separate(date, c("year", "month", "day", "hour", "min", "sec")) # create year, month, and day column columns
path_gps$date <- paste(path_gps$year, path_gps$month, path_gps$day, sep = ".") # creates a full date column (XYear.Month.Day)
path_gps <- path_gps[, -c(2:7)] # remove columns for hour, minute, and seconds (we won't use these)
path_gps <- spread(path_gps, reef, sst)

## save the final dataframe (.csv or Rdata)
#write.csv(path_gps, file = "data/Pathfinder/Pathfinder_reefs_SST_update.csv") # to save file as .csv
saveRDS(path_gps, file = "data/Pathfinder/Pathfinder_reefs_SST_update.rds") # to save file as Rdata (I saved as Rdata since it is large)

```

```{r Pathfinder monthly SST dataframe construction}

path_gps <- readRDS("data/Pathfinder/Pathfinder_reefs_SST.rds")

## create a new dataframe of simple stats per time
path_full <- data.frame("date" = path_gps[,1],
                        "mean_temp" = rowMeans(path_gps[,-1], na.rm = TRUE),
                        "max_temp" = apply(path_gps[,-1], 1, FUN=max, na.rm = TRUE),
                        "min_temp" = apply(path_gps[,-1], 1, FUN=min, na.rm = TRUE),
                        "n" = length(path_gps[,-1]))

path_full <- path_full %>% separate(date, c("year", "month","day"), convert = TRUE) # create year, month, and day column columns
path_full$year <- as.numeric(gsub("\\X", "", path_full$year)) # convert the year column to numerics and remove 'X'
path_full$month2 <- factor(path_full$month) # make a month as a factor column for plotting

```

```{r Pathfinder monthly SST per year, fig.align='center'}

#### Data visualization of monthly SST per year #### 

# calculate summary statistic per month across years
Path_month_avg <- path_full %>% 
  group_by(month) %>% 
  summarise(mean = mean(mean_temp, na.rm = TRUE),
            sd = sd(mean_temp, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se)

# make year integer for better plotting
path_full$year <- as.integer(path_full$year)

## create plots of monthly Pathfinder per year
# markdown plot
path_month_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 45, hjust = 1), text = element_text(size = 14)) +
  theme(legend.position = c(0.065, 0.85), legend.key.size = unit(0.3, "cm"), legend.background = element_rect(fill = NA), plot.title = element_text(size = 12)) + # legend theme
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  geom_line(data = path_full, aes(x = month, y = mean_temp, group = year, colour = year), alpha = 0.6, size = 0.4) +
  scale_colour_gradient2("", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(path_full$year), space="Lab") +
  scale_x_continuous(name = "Month", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  ylab('SST (°C)') +
  ggtitle("Pathfinder (1981–2019)") + 
  theme(plot.title = element_text(size = 13))

```
  
```{r Pathfinder annual SST}

## construct df for the GAM smoothing of mean SST
path_gam_df <- gather(path_gps, reef, sst, `1`:`5607`)
path_gam_df$date <- gsub("\\X", "", path_gam_df$date) # convert year to numeric and remove 'X'
path_gam_df <- path_gam_df %>% separate(date, c("year", "month","day"), convert = TRUE) # create year, month, and day column columns
path_gam_df <- subset(path_gam_df, year != "2020") # exclude 2020 data


## Pathfinder GAMM:
path_gam <- gamm(sst ~ s(year, bs = 'cr', k = 9) + s(month, bs = 'cc', k = 12), data = path_gam_df)

## Below is model checking for GAMs that should be checked out before proceeding when fitting a new GAM
#layout(matrix(1:4, ncol = 2))
#summary(path_gam$gam)
#gam.check(path_gam$gam)
#plot(path_gam$gam)
#qq.gam(path_gam)

path_gam_pred <- predict.gam(path_gam$gam, type = "response", se.fit = TRUE, exclude = s(month), newdata = path_gam_df[1:2]) # predict response-level values from the GAM per year
path_predict_df <- cbind(path_gam_df, response = path_gam_pred$fit, lwr = path_gam_pred$fit - 2 * path_gam_pred$se.fit, upr = path_gam_pred$fit + 2 * path_gam_pred$se.fit) # add the predicted fit and lower/upper CIs to the GAM dataframe

#### Data visualization per year across months #### 

# calculate summary statistic per month across years
Path_year_avg <- path_full %>% 
  group_by(year) %>% 
  summarise(mean = mean(mean_temp, na.rm = TRUE),
            max = max(mean_temp, na.rm = TRUE),
            min = min(mean_temp, na.rm = TRUE),
            sd = sd(mean_temp, na.rm = TRUE),
            n = n()) %>% 
  mutate(se = sd / sqrt(n),
         lowerci = mean - qt(1 - (0.05 / 2), n - 1) * se,
         upperci = mean + qt(1 - (0.05 / 2), n - 1) * se,
         range = max - min)


## plot with smoothed trend
path_year_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), text = element_text(size = 14)) +
  #geom_vline(xintercept = 1981, colour = "lightgrey") +
  geom_hline(yintercept = mean(Path_year_avg[-1,]$mean), colour = "grey", linetype = 2) +
  geom_ribbon(data = Path_year_avg[-1,], aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.3, linetype = 1) + 
  #geom_line(data = Path_year_avg[-1,], aes(x = year, y = mean), colour = "black", group = 1, size = 1, alpha = 0.7) + # mean sst
  scale_x_continuous(name = "Year") +
  ylab('SST (°C)') +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.5) + # max sst
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.5) + # min sst
  geom_smooth(data = path_gam_df, method = "gam", aes(x = year, y = sst), colour = "black", group = 1, size = 1, se = FALSE, formula = y ~ s(x, bs = "cs")) + # smoothed mean temp over all data
  coord_cartesian(xlim = c(1981, 2019))

```

```{r Pathfinder combined figure, fig.align='center', fig.width=6, fig.height=7.5}

# Saves the manuscript version of the Pathfinder historic SST
ggarrange(path_month_plot, path_year_plot, ncol = 1, labels = c("A", "B"), align = "hv")
  ggsave("figures/Supplemental/FigS2_Pathfinder_SST_trends.pdf", width = 6, height = 7.5)
  ggsave("figures/Supplemental/FigS2_Pathfinder_SST_trends.png", width = 6, height = 7.5)

```

**Supplemental Figure 2.** Historic SST records (1981-2019; Pathfinder) on Caribbean coral reefs depicting **A**) mean monthly SST each year (represented by line colour: blue to red) and **B**) GAM smoothed annual mean SST time (black line), annual maximum (red line), and annual minimum (blue line) SST. The grey dashed horizontal line denotes the overall mean SST for all sites over the entire period (27.23 °C) and the grey ribbon represents the 95% confidence interval around the true annual SST mean through time. 

<br/>


### Figure S3

```{r figure S3 comparing SST on reefs between databases}

had_subset <- filter(had_full, year > 1981 & year < 2020)
path_subset <- filter(path_full, year > 1981 & year < 2020)


combo_data <- data.frame(year = had_subset$year,
                         Month = had_subset$month,
                         HadISST = had_subset$mean_temp,
                         Pathfinder = path_subset$mean_temp)

## Linear regression of databases
had_path_lm <- lm(Pathfinder ~ HadISST, data = combo_data)
had_path_lm_sum <- summary(had_path_lm)


## Plot the regression of databases
ggplot(data = combo_data, aes(x = HadISST, y = Pathfinder)) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), strip.background = element_blank(), text = element_text(size = 14), legend.position = c(0.07, 0.8), legend.background = element_blank()) +
  geom_point(aes(colour = Month), alpha = 0.4, size = 3) +
  scale_color_gradient2(midpoint = 9, low = "#2166ac", mid = "#d6604d", high = "#2166ac") +
  geom_smooth(method = lm, se = FALSE, colour = "black") +
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  labs(x = "HadISST (°C)", y = "Pathfinder (°C)") +
  annotate("text", x = 29.7, y = 25, label = bquote(italic(R)^2 == .(format(had_path_lm_sum$adj.r.squared, digits = 2)))) +
  annotate("text", x = 29.7, y = 24.7, label = "P < 0.001") + 
  ggtitle("Monthly temperature comparison (1982 - 2019)")
ggsave("figures/Supplemental/Fig3_PathVhadISST.pdf", width = 8, height = 5)
ggsave("figures/Supplemental/Fig3_PathVhadISST.png", width = 8, height = 5)

```

**Supplemental Figure 3.** Comparison of monthly SST (°C) recorded in the HadISST and Pathfinder databases from 1982-2019. SST values were regressed against one another for the same time for comparison of the relationship between the databases. Points are depicted by month (cooler months in blue and warmer months in red) and the black line represents the resulting linear regression model (R^2^ = `r round(had_path_lm_sum$adj.r.squared, 2)`; P < 0.001).

<br/>


### Figure S4

```{r combined annual SST plot}

## plot with smoothed trend
combo_plot <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  # add the HadISST dataset
  geom_hline(yintercept = mean(HADI_year_avg$mean), colour = "darkgrey", linetype = 2) +
  geom_ribbon(data = HADI_year_avg, aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.05, linetype = 1) + 
  geom_line(data = HADI_year_avg, aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.5, alpha = 0.3) +
  geom_line(data = HADI_year_avg, aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.5, alpha = 0.3) + 
  geom_line(data = HADI_year_avg, aes(x = year, y = mean), colour = "darkgrey", group = 1, size = 0.5, alpha = 0.3) + 
  geom_smooth(data = HADI_year_avg, method = "gam", aes(x = year, y = mean), formula = y ~ s(x, bs = "cs"), colour = "darkgrey", group = 1, size = 1, se = FALSE, alpha = 0.3) +
  # add the Pathfinder dataset on top
  geom_hline(yintercept = mean(Path_year_avg[-1,]$mean), colour = "black", linetype = 2) +
  geom_ribbon(data = Path_year_avg[-1,], aes(x = year, ymin = lowerci, ymax = upperci), colour = "darkgrey", alpha = 0.3, linetype = 1) +
  scale_x_continuous(name = "Year", breaks = c(1880, 1900, 1920, 1940, 1960, 1980, 2000, 2020)) +
  ylab('SST (°C)') +
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = max), colour = "#d6604d", group = 1, size = 0.5) +
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = min), colour = "#2166ac", group = 1, size = 0.5) + 
  geom_line(data = Path_year_avg[-1,], aes(x = year, y = mean), colour = "black", group = 1, size = 0.5) + 
  geom_smooth(data = Path_year_avg[-1,], method = "gam", aes(x = year, y = mean), formula = y ~ s(x, bs = "cs"), colour = "black", group = 1, size = 1, se = FALSE) +
  ggtitle("Caribbean coral reefs historic SST trends") +
  scale_y_continuous(breaks = seq(24, 30, 1)) +
  coord_cartesian(xlim = c(1870, 2020))
  ggsave("figures/Supplemental/FigS4_Both_SST_trends.pdf", width = 6, height = 4)
  ggsave("figures/Supplemental/FigS4_Both_SST_trends.png", width = 6, height = 4)

ggplotly(combo_plot)

```

**Supplemental Figure 4.** Comparison of HadISST (1871-2020) and Pathfinder (1981-2019) SST recorded on Caribbean coral reef locations. The high-resolution Pathfinder is represented as darker data over the long-term HadISST. Both datasets are represented by GAM smoothed annual mean SST time (solid line), annual maximum (red line), and annual minimum (blue line) SST. The dashed horizontal line denotes the overall mean SST for all sites over the entire period and the grey ribbon represents the 95% confidence interval around the true annual SST mean through time. 

<br/>


### Figure S5

![](figures/Supplemental/FigS5_Ecoregion_MapSST.png)

**Supplemental Figure 5.** Historic SST trends on coral reefs within Caribbean ecoregions (1871 - 2020) with corresponding reef locations (see **Figures 1, 3** in the main text). The colour of each reef location and box around long-term SST (HadISST) plots represent the designated ecoregion. Plots depict SST data with GAM smoothed annual mean SST time (black line), annual maximum (red line), and annual minimum (blue line) SST. The grey dashed horizontal line denotes the mean SST over the entire period and the grey ribbon represents the 95% confidence interval around the true annual SST mean for the  A) Bahamian, B) Eastern Caribbean, C) Floridian, D) Greater Antilles, E) Gulf of Mexico, F) Southern Caribbean, G) Southwestern Caribbean, and H) Western Caribbean ecoregions. 

<br/>


### HadISST GIF

```{r HadISST GIF, fig.align='center'}

## create version of the plot for creating a GIF of HadISST data
had_plot_gif <- ggplot() +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1), axis.text.x = element_text(angle = 45, hjust = 1), text = element_text(size = 20)) +
  guides(colour = guide_colorbar(frame.colour = "black", ticks.colour = "black")) +
  geom_line(data = had_full, aes(x = month, y = mean_temp, group = year, colour = year), size = 1) +
  scale_colour_gradient2("Year", low = "#2166ac", mid = "#d1e5f0", high = "#d6604d", midpoint = mean(had_full$year), space="Lab") +
  #annotate(geom = "text", size = 4, x = 11, y = 24.6, label = "@DrSeaBove7", colour = "grey20") +
  coord_cartesian(ylim = c(24.5, 30), clip = "off") +
  scale_x_continuous(name = "Month", breaks = c(1,2,3,4,5,6,7,8,9,10,11,12), labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")) +
  ylab('SST (°C)')

## below is code to transform the HadISST monthly SST plot into a GIF (not shown in the Rmarkdown file, but saved in the figures folder)
# SST is plotted one year at a time in order in the GIF

had_gif <- had_plot_gif + 
  transition_time(year) +
  labs(title = "Year: {frame_time} (HadISST)") +
  shadow_mark(alpha = 0.1, size = 0.5)

animate(had_gif, fps = 10, nframes = 300, end_pause = 2, width = 650, height = 400, renderer = gifski_renderer())
#anim_save("figures/Supplemental/HadISST.gif")
anim_save("HadISST_twitter.gif")

```

Long-term SST records (HadISST) on Caribbean coral reefs depicting mean monthly SST each year (represented by line colour: blue to red).

<br/>


## Caribbean Basin Maps and Marine Heatwaves {.tabset}

### <span style="color: #0072B2;">**Figure 4**</span>

```{r Pathfinder SST slope map}

### Pathfinder SST slope map

## Clip Pathfinder slopes by MHW bounds
load("data/Pathfinder/Pathfinder_slope.Rdata") # load Rdata of the modified Pathfinder raster
path_slope <- path_slope[c(2,3,1)] # just reordering the dataframe
coordinates(path_slope) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(path_slope) <- proj # modify projection to match Pathfinder
path_clipped <- path_slope[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
path_slope_clipped <- as.data.frame(path_clipped) # convert to dataframe

## Plot Pathfinder slope map
path_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(data = path_slope_clipped, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = FALSE) + 
  scale_fill_distiller("ºC per decade", palette = "RdYlBu", limits = c(-0.3, 0.4)) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  theme(panel.background = element_rect(fill = "grey95")) +
  labs(x = "", y = "") +
  ggtitle(paste0("Caribbean warming rate (1981-2019)"))

# save a version for the markdown visual
path_map_markdown <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = path_slope_clipped, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = FALSE) + 
  scale_fill_distiller("ºC per decade", palette = "RdYlBu", limits = c(-0.3, 0.4)) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  theme(panel.background = element_rect(fill = "grey95")) +
  labs(x = "", y = "") +
  ggtitle(paste0("Caribbean warming rate (1981-2019)"))




## Clip Pathfinder pvalues by MHW bounds
path_pavl <- read.csv("data/Pathfinder/Pathfinder_pval.csv", header = TRUE) # read in the saved .csv of the dataframe
path_pavl <- path_pavl[c(2,3,1, 4)] # just reordering the dataframe
coordinates(path_pavl) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(path_pavl) <- proj # modify projection to match Pathfinder
pathP_clipped <- path_pavl[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
pathP_slope_clipped <- as.data.frame(pathP_clipped) # convert to dataframe
pathP_slope_clipped$bins <- factor(pathP_slope_clipped$bins, levels = c("< 0.0001", "0.0001 - 0.001", "0.001 - 0.01", "0.01 - 0.05", "0.05 - 0.1", "> 0.1"))


## Plot Pathfinder significance map
path_pval_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(data = pathP_slope_clipped, aes(x = x, y = y, fill = bins), alpha=0.8, interpolate = FALSE) +
  scale_fill_brewer("p-value", palette = "PuBu", direction = -1) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  theme(panel.background = element_rect(fill = "grey95")) +
  labs(x = "", y = "") +
  ggtitle("Significance of Caribbean warming (1981-2019)")

# save a version for the markdown visual
path_pval_markdown <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(data = pathP_slope_clipped, aes(x = x, y = y, fill = bins), alpha=0.8, interpolate = FALSE) +
  scale_fill_brewer("p-value", palette = "PuBu", direction = -1) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  theme(panel.background = element_rect(fill = "grey95")) +
  labs(x = "", y = "") +
  ggtitle("SST warming (1981-2019)")

```

*All Marine Heatwave analyses were performed by Laura Mudge (GitHub: [Lmudge13](https://github.com/Lmudge13))*

Laura's code/analyses are included in this script and identified within code chunks when pulled or modified from her original work.

```{r OISST MHW frequency map}

### OISST MHW map code modified from Laura Mudge's original analysis.
# Here, I am just working with Laura's compiled MHW data for the Caribbean 
# Laura's original OISST MHW analysis of the Caribbean can be found at her GitHub repository: https://github.com/Lmudge13/MHW_spatial_correlation

### MHW slope map
MHW_trends <- read_rds(MHW_path) # load in trend data
MHW_trends$lon <- MHW_trends$lon- 360 # convert lon back into -180 to 180

# add a second pval column- for the breaks used in the map_p plot below
#MHW_trends <- MHW_trends %>% 
#  mutate(pvalb = cut(p, breaks = c(0, 0.001, 0.01, 0.05, .10, .50, 1)))
MHW_trends$bins <- cut(MHW_trends$p, breaks = bins, labels = bin_names) # bins the pvales into 6 unique bins for plotting
MHW_trends$bins <- factor(MHW_trends$bins, levels = c("< 0.0001", "0.0001 - 0.001", "0.001 - 0.01", "0.01 - 0.05", "0.05 - 0.1", "> 0.1"))


## MHW slopes map
map_slope <- ggplot(MHW_trends, aes(x = lon, y = lat)) + 
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  #geom_rect(size = 0.2, fill = NA, aes(xmin = lon - 0.1, xmax = lon + 0.1, ymin = lat - 0.1, ymax = lat + 0.1, colour = pval)) +
  geom_raster(aes(fill = slope), interpolate = FALSE, alpha = 0.9) +
  scale_fill_distiller("MHW per year", palette = "RdYlBu", limits = c((min(MHW_trends$slope)-0.04), max(MHW_trends$slope))) +
  #scale_color_brewer("MHW per year", palette = "RdYlBu", name = "p-value", guide = FALSE) +
  geom_polygon(data = map_base, aes(group = group), colour = "#575757", fill = "grey81") +
  theme(panel.background = element_rect(fill = "grey95")) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  ggtitle("Change in marine heat wave frequency (1981-2018)")

# markdown version of above
mhw_map_markdown <- ggplot(MHW_trends, aes(x = lon, y = lat)) + 
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  #geom_rect(size = 0.2, fill = NA, aes(xmin = lon - 0.1, xmax = lon + 0.1, ymin = lat - 0.1, ymax = lat + 0.1, colour = pval)) +
  geom_raster(aes(fill = slope), interpolate = FALSE, alpha = 0.9) +
  scale_fill_distiller("MHW per year", palette = "RdYlBu", limits = c((min(MHW_trends$slope)-0.04), max(MHW_trends$slope))) +
  #scale_color_brewer("MHW per year", palette = "RdYlBu", name = "p-value", guide = FALSE) +
  geom_polygon(data = map_base, aes(group = group), colour = "#575757", fill = "grey81") +
  theme(panel.background = element_rect(fill = "grey95")) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  ggtitle("Change in MHW frequency (1981-2018)")



## MHW significance map
map_p <- ggplot(MHW_trends, aes(x = lon, y = lat)) + 
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(aes(fill = bins), alpha=0.8, interpolate = FALSE) +
  scale_fill_brewer("p-value", palette = "PuBu", direction = -1) +
  geom_polygon(data = map_base, aes(group = group), colour = "#575757", fill = "grey81") +
  theme(panel.background = element_rect(fill = "grey95")) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  ggtitle("Significance of change in heat wave frequency (1981-2018)")

# markdown version of above
mhw_pval_markdown <- ggplot(MHW_trends, aes(x = lon, y = lat)) + 
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom") +
  geom_raster(aes(fill = bins), alpha=0.8, interpolate = FALSE) +
  scale_fill_brewer("p-value", palette = "PuBu", direction = -1) +
  geom_polygon(data = map_base, aes(group = group), colour = "#575757", fill = "grey81") +
  theme(panel.background = element_rect(fill = "grey95")) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  ggtitle("Change in MHW frequency (1981-2018)")


```

```{r combined SST and MHW maps}

### Combined plots
Figure4 <- ggarrange(path_map, map_slope, labels = c("A", "B"))
  ggsave("figures/Manuscript/Fig4_SST_MHW_map.pdf", width = 14.5, height = 5)

# markdown version
ggarrange(path_map_markdown, mhw_map_markdown, labels = c("A", "B"))

```

**Fig 4. Warming patterns throughout the Caribbean Sea.** Increasing warming events across the Caribbean depicted through A) rate of SST change (°C per decade) from 1981 to 2019 (Pathfinder; mean slope `r round(mean(path_slope_clipped$sst), 2)` °C per decade) and B) increasing marine heatwave events (slope of counts per year). Grey ocean area was not included in these analyses. Map layer was acquired from Natural Earth ([https://www.naturalearthdata.com](https://www.naturalearthdata.com)).

---

<br/>


### <span style="color: #0072B2;">**Figure 5**</span>

```{r Caribbean MHW data manipulation}

### Caribbean coral reef MHW metrics analyses modified from Laura Mudge's original analysis.
# Here, I am just working with Laura's compiled MHW data for the Caribbean 
# Laura's original OISST MHW analysis of the Caribbean can be found at her GitHub repository: https://github.com/Lmudge13/MHW_spatial_correlation

## Read in dataframe of MHWs across the Caribbean (this is too big to host on GitHub so using dropbox path)
mhw_carib <- read_csv(MHW_carib_path)


## Add a column for year & calculate return time:
  # year = year of MHW event
  # days_since_last = return time in number days since last MHW event ended
  # grid_ID= id variable for the lat/lon grid

mhw_carib <- mhw_carib %>% 
  mutate(year= lubridate::year(date_start)) %>%
  group_by(lon,lat) %>% 
  mutate(end_lagged = lag(date_end)) %>% 
  mutate(days_since_last = as.integer(date_start - end_lagged)) %>%
  ungroup() %>%
  mutate(unique_ID= as.numeric(interaction(lat,lon))) %>%
    #transform current lon to lon 365 and create lon col that has longitude in the E-W format (values should be between -100 and -55)
  rename(lon365=lon) %>%
  mutate(lon= lon365-360) 
  
  
## filter out areas in Pacific (near panama, confirmed lat/lon in code chunk below)
pac_range <-  mhw_carib %>% 
  filter(between(lon, -84, -78) & between(lat, 7, 8.5) |
           between(lon, -84, -82.5) & between(lat, 8.5, 9.5) | 
           between(lon, -80, -78) & between(lat, 8.5, 9))

mhw_carib <- anti_join(mhw_carib, pac_range)

    
## Create a summary df of MHW metrics per year for each lat/lon:
mhw_sum <- mhw_carib %>%
  group_by(lat, lon, year) %>%
  mutate(total_MHW_days = sum(duration),
         total_events = length(event_no),
         avg_onset = mean(rate_onset), # deg C/day
         avg_duration = mean(duration), # days
         avg_intensity = mean(intensity_mean), # deg C 
         avg_rt = mean(days_since_last)
         ) %>%
  distinct(lat, lon, unique_ID, year, total_MHW_days, total_events, avg_onset, avg_duration, avg_intensity, avg_rt)

```

```{r reef-specific MHW data manipulation}

# MHW on REEFS 9/13/2019: this will have mhw data with ecoregion and EEZ info
#mhw_carib_reefs <- read_csv("/Users/colleen/Dropbox/Git/CaribbeanSST/data/ReefData/CaribbeanReef_points.csv")
mhw_carib_reefs <- read_csv("data/ReefData/MHW_reefs.csv")

mhw_carib_reefs <- mhw_carib_reefs %>%
  filter(ecoregion != "Brazil" & ecoregion != "Bermuda")

# add column in mhw_carib_reefs that has the average max intensity
  # 1: use mhw_carib to find average max intensity per year, based on MHW grid ID
intensity_vars <- mhw_carib %>%
  group_by(unique_ID, year) %>%
  mutate(avg_maxint = mean(intensity_max),
         avg_cumint = mean(intensity_cumulative)) %>%
  distinct(unique_ID, year, avg_maxint, avg_cumint)
  
  # 2: add avg_maxint and avg_cumint into the mwh_carib_reefs, matching by year and ID- WORKS!
mhw_carib_reefs$avg_maxint <- intensity_vars$avg_maxint[match(interaction(mhw_carib_reefs$mhw_ID,mhw_carib_reefs$year), interaction(intensity_vars$unique_ID, intensity_vars$year))]

mhw_carib_reefs$avg_cumint <- intensity_vars$avg_cumint[match(interaction(mhw_carib_reefs$mhw_ID,mhw_carib_reefs$year), interaction(intensity_vars$unique_ID, intensity_vars$year))]

# organize data per ecoregion / year
mhw_ecoregion_sum <- mhw_carib_reefs %>%
  group_by(ecoregion, year) %>%
  mutate(mean_days = mean(total_MHW_days),
         mean_events = mean(total_events),
         mean_onset = mean(avg_onset), # deg C/day
         mean_duration = mean(avg_duration), # days
         mean_avgint = mean(avg_intensity), # deg C 
         mean_maxint = mean(avg_maxint),
         mean_cumint = mean(avg_cumint),
         mean_rt = mean(avg_rt)
         ) %>%
  distinct(ecoregion, year, .keep_all=TRUE) %>%
  dplyr::select(-c(mhw_lat:mhw_ID), -c(total_MHW_days:Distance), -c(avg_maxint:avg_cumint)) 

## Create a dataframe that keeps MHW from distinct MHW pixels (ie multiple reefs can be included in the pixel, but we are only keeping 1 timeseries per pixel). Include ecoregion in distinct incase 1 pixel spans 2 different ecoregions

mhw_pixel <- mhw_carib_reefs %>%
  distinct(mhw_ID, year, ecoregion, .keep_all=TRUE) %>%
  dplyr::select(-reef_id,-CloseTempIndex, -Distance, -lon, -lat)
  # has 545 unique MHW grids (mhw_ID)


# fill in missing years
mhw_pixel <- mhw_pixel %>%
    # need to create a year column that is an as.Date format
  mutate(yeard = as.Date(paste(year, 1, 1, sep = "-"))) %>%
    # grouping by these vars so they are filled in
  group_by(mhw_ID, ecoregion, mhw_lon, mhw_lat) %>%
    # this will fill in any missing years, other col values will all be NA
  complete(yeard = seq.Date(min(yeard), max(yeard), by="year")) %>%
  mutate(year = lubridate::year(yeard)) %>%
  dplyr::select(-yeard) %>%
  mutate(total_MHW_days = replace_na(total_MHW_days, 0),
         total_events = replace_na(total_events, 0))


## Create new ecoregion labels for MHW plots
eco_labs <- c("Bahamas", "E. Carib", "Florida", "Antilles", "Gulf of Mexico", "S. Carib", "SW Carib", "W. Carib")
names(eco_labs) <- c("Bahamian", "Eastern Caribbean", "Floridian", "Greater Antilles", "Gulf of Mexico", "Southern Caribbean", "Southwestern Caribbean", "Western Caribbean")


```


```{r MHW frequency assessment}  

## Running a GLM because this is count data 

# GLM model:
pixel_frequency_glm <- glm(total_events ~ year, poisson(link = "log"), data = mhw_pixel %>% filter(!is.na(total_events)))

#tab_model(pixel_frequency_glm, show.se = TRUE, show.ci = FALSE, show.stat = TRUE, show.obs = FALSE, transform = NULL, dv.labels = "Frequency")
freq_mod <- tidy(pixel_frequency_glm)

frequency_df <- mhw_pixel %>% 
  filter(!is.na(total_events)) %>% 
  add_predictions(pixel_frequency_glm, type = "response")


# Diagnosis of model:
#check_model(pixel_frequency_nb)
#summary(pixel_frequency_glm)


# make label of  R2 value for plot:
freq_r2 <- NagelkerkeR2(pixel_frequency_glm)[[2]]
freq_rlab <- paste("italic(R^2) == ", round(freq_r2, 4))

```

```{r MHW frequency plot}

## Create plot of MHW frequency for coral reefs
plot_freq_pixel <- ggplot(data=frequency_df, aes(x= year, y= total_events)) +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1)) + 
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", width = 0) +
  stat_summary(fun = "mean", size = 0.3) +
  geom_line(aes(x = year, y = pred), colour = "steelblue", size = 1) +
  annotate(geom = "text", size = 2.8, x = 1985, y = 10, label = freq_rlab, parse=TRUE, colour = "grey20") +
  expand_limits(x = c(1980, 2020)) +  
  labs(x="Year", y="Frequency")

```


```{r MHW duration assessment} 

## Running a regression for return time 

# LM model:
pixel_duration_lm <- lm(log(avg_duration) ~ year, data = mhw_pixel %>% filter(!is.na(avg_duration)))

#tab_model(pixel_duration_lm, show.se = TRUE, show.ci = FALSE, show.stat = TRUE, show.obs = FALSE, dv.labels = "Duration")
dur_mod <- tidy(pixel_duration_lm)
  
# Diagnosis of model:
check_model(pixel_duration_lm)
#summary(pixel_duration_lm)


# make label of  R2 value for plot:
dur_r2 <- summary(pixel_duration_lm)$r.squared
dur_rlab <- paste("italic(R^2) == ", round(dur_r2, 4))

```

```{r MHW duration plot}

## Create plot of MHW duration for coral reefs
plot_dur_pixel <- ggplot(data = mhw_pixel %>% filter(!is.na(avg_duration)), aes(x= year, y= avg_duration)) +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1)) + 
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", width = 0) +
  stat_summary(fun = "mean", size = 0.3) +
  geom_smooth(method = "lm", colour = "steelblue", size = 1) +
  annotate(geom = "text", size = 2.8, x = 1985, y = 41, label = dur_rlab, parse=TRUE, colour = "grey20") +
  expand_limits(x = c(1980, 2020)) +  
  labs(x="Year", y="Duration (days)")

```


```{r MHW return time assessment} 

## Running a regression for return time 

# LM model:
pixel_rt_lm <- lm(log(avg_rt) ~ year, data = mhw_pixel %>% filter(!is.na(avg_rt)))
#summary(pixel_rt_lm)
#tab_model(pixel_rt_lm, show.se = TRUE, show.ci = FALSE, show.stat = TRUE, show.obs = FALSE, dv.labels = "Return Time")
rt_mod <- tidy(pixel_rt_lm)

# Diagnosis of model:
check_model(pixel_rt_lm)

# make label of  R2 value for plot:
rt_r2 <- summary(pixel_rt_lm)$r.squared
rt_rlab <- paste("italic(R^2) == ", round(rt_r2, 4))

```

```{r MHW return time plot}

## Create plot of MHW return time for coral reefs
plot_rt_pixel <- ggplot(data = mhw_pixel %>% filter(!is.na(avg_rt)), aes(x= year, y= avg_rt)) +
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=1)) + 
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", width = 0) +
  stat_summary(fun = "mean", size = 0.3) +
  geom_smooth(method = "lm", colour = "steelblue", size = 1) +
  annotate(geom = "text", size = 2.8, x = 2015, y = 1400, label = rt_rlab, parse=TRUE, colour = "grey20") +
  expand_limits(x = c(1980, 2020)) +  
  labs(x="Year", y="Return Time (days)")

```


```{r combine and save MHW figure 5, fig.height = 3, fig.width = 10}

## Final combined MHW plot and save it
ggarrange(plot_freq_pixel, plot_dur_pixel, plot_rt_pixel, ncol = 3, labels = "AUTO")
  ggsave("figures/Manuscript/Fig5_MHW_metrics.pdf", width = 10, height = 3)

```

**Fig 5. MHW trends (1981–2018) across Caribbean coral reefs.** Temperature data are based on OISST gridded data to determine A) marine heat wave (MHW) frequency (number events per year) with Nagelkerke pseudo R^2^; B) MHW duration (number days per event) with linear model R^2^ ; and C) return time (number days per event) since the previous MHW event with linear model R^2^ reported. Points denote annual mean values (±SD) and blue lines represent linear (lm or glm) trends. 

---

<br/>


### Figure S6

```{r combined SST and MHW p value maps}

## Combined p values:
FigureS6 <- ggarrange(path_pval_map, map_p, align = "hv", labels = c("A", "B"))
  ggsave("figures/Supplemental/FigS6_SST_MHW_significance_map.pdf", width = 14.5, height = 5)
  ggsave("figures/Supplemental/FigS6_SST_MHW_significance_map.png", width = 14.5, height = 5)

# markdown version of plot
ggarrange(path_pval_markdown, mhw_pval_markdown, align = "hv", labels = c("A", "B")) 

```

**Supplemental Figure 6.** Significance of A) rate of SST change (°C per decade) and B) number of marine heatwave events per year across the Caribbean depicted in **Figure 4**. Grey ocean area was not included in these analyses.

---

<br/>


### Figure S7

```{r HadISST full SST map, message=FALSE, warning=FALSE}

load(file = "data/HadISST/HadISST_slopes.Rdata")

## Clip HadISST slopes by MHW bounds
had_slope_b <- had_slope[c(2,3,1)] # just reordering the dataframe
coordinates(had_slope_b) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(had_slope_b) <- proj # modify projection to match Pathfinder
had_clipped <- had_slope_b[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
had_slope_clipped <- as.data.frame(had_clipped) # convert to dataframe

## Plot the map
had_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(data = had_slope_clipped, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = FALSE) + 
  scale_fill_distiller("ºC per decade", palette = "RdYlBu", limits = c(min(had_slope_clipped$sst), max(had_slope_clipped$sst))) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  theme(panel.background = element_rect(fill = "grey95")) +  
  ggtitle(paste0("Caribbean warming rate (", format.Date(start_date, "%Y"), "-", format.Date(end_date, "%Y"), ")"))


```

```{r HadISST full SST pval map, message=FALSE, warning=FALSE}

load(file = "data/HadISST/HadISST_pvals.Rdata")

## Clip Pathfinder slopes by MHW bounds
had_pavl_b <- had_pavl[c(2,3,1, 4)] # just reordering the dataframe
coordinates(had_pavl_b) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(had_pavl_b) <- proj # modify projection to match Pathfinder
had_p_clipped <- had_pavl_b[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
had_pavl_clipped <- as.data.frame(had_p_clipped) # convert to dataframe
had_pavl_clipped$bins <- factor(had_pavl_clipped$bins, levels = c("< 0.0001", "0.0001 - 0.001", "0.001 - 0.01", "0.01 - 0.05", "0.05 - 0.1", "> 0.1"))


## Plot the map
had_pval_map <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(data = had_pavl_clipped, aes(x = x, y = y, fill = bins), alpha=0.8, interpolate = FALSE) +
  scale_fill_brewer("p-value", palette = "PuBu", direction = -1) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  theme(panel.background = element_rect(fill = "grey95")) +  
  ggtitle("SST slope significance")

```

```{r HadISST full SST map combo, message=FALSE, warning=FALSE, fig.align='center', fig.width=12, fig.height=6}

ggarrange(had_map, had_pval_map, labels = c("A", "B"))
  ggsave("figures/Supplemental/FigS7_HadISST_map.pdf", width = 14, height = 5)
  ggsave("figures/Supplemental/FigS7_HadISST_map.png", width = 14, height = 5)

```

**Supplemental Figure 7. A**) Rate of SST change (°C per decade) over the duration of the HadISST database across the Caribbean from 1871 to 2020 (mean slope `r round(mean(had_slope_clipped$sst), 2)` ± `r round(sd(had_slope_clipped$sst), 3)` °C per decade) and **B**) significance of rate of SST change. Grey ocean area was not included in these analyses.

---

<br/>


### Figure S8

```{r HadISST SST map subset (1981-2019), message=FALSE, warning=FALSE}

## Clip HadISST slopes by MHW bounds
had_slope_sub_b <- had_slope_sub[c(2,3,1)] # just reordering the dataframe
coordinates(had_slope_sub_b) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(had_slope_sub_b) <- proj # modify projection to match Pathfinder
had_s_slope_clipped <- had_slope_sub_b[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
had_slope_sub_clipped <- as.data.frame(had_s_slope_clipped) # convert to dataframe


## Plot the map
had_map_sub <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(data = had_slope_sub_clipped, aes(x = x, y = y, fill = sst), alpha=0.8, interpolate = FALSE) + 
  scale_fill_distiller("ºC per decade", palette = "RdYlBu", limits = c(min(had_slope_sub_clipped$sst), max(had_slope_sub_clipped$sst))) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  guides(fill = guide_colorbar(frame.colour = "black", ticks.colour = "black", barwidth = 12)) +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  theme(panel.background = element_rect(fill = "grey95")) +  
  ggtitle(paste0("Caribbean warming rate (", format.Date(start_dateb, "%Y"), "-", format.Date(end_date, "%Y"), ")"))

```

```{r HadISST SST pval map subset (1981-2019), message=FALSE, warning=FALSE}

## Clip Pathfinder slopes by MHW bounds
had_pval_sub_b <- had_pval_sub[c(2,3,1, 4)] # just reordering the dataframe
coordinates(had_pval_sub_b) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(had_pval_sub_b) <- proj # modify projection to match Pathfinder
had_p_sub_clipped <- had_pval_sub_b[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
had_pval_sub_b_clipped <- as.data.frame(had_p_sub_clipped) # convert to dataframe
had_pval_sub_b_clipped$bins <- factor(had_pval_sub_b_clipped$bins, levels = c("< 0.0001", "0.0001 - 0.001", "0.001 - 0.01", "0.01 - 0.05", "0.05 - 0.1", "> 0.1"))


## Plot the map
had_pval_map_sub <- ggplot() +  
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background=element_blank(), strip.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1), legend.position = "bottom", text = element_text(size = 15), title = element_text(size = 13)) +
  geom_raster(data = had_pval_sub_b_clipped, aes(x = x, y = y, fill = bins), alpha=0.8, interpolate = FALSE) +
  scale_fill_brewer("p-value", palette = "PuBu", direction = -1) +
  geom_polygon(data = map_base, aes(group = group, x = lon, y = lat), colour = "#575757", fill = "grey81") +
  coord_sf(xlim = c(-100,-55), ylim = c(7.65,33), expand = FALSE) +
  labs(x = "", y = "") +
  theme(panel.background = element_rect(fill = "grey95")) +  
  ggtitle("SST slope significance")

```

```{r HadISST SST map subset combo, message=FALSE, warning=FALSE, fig.align='center', fig.width=12, fig.height=6}

ggarrange(had_map_sub, had_pval_map_sub, labels = c("A", "B"))
  ggsave("figures/Supplemental/FigS8_HadISST_subset_map.pdf", width = 14, height = 5)
  ggsave("figures/Supplemental/FigS8_HadISST_subset_map.png", width = 14, height = 5)

```

**Supplemental Figure 8. A**) Rate of SST change (°C per decade) across the Caribbean from 1981 to 2020 (HadISST; mean slope `r round(mean(had_slope_sub_clipped$sst), 2)` ± `r round(sd(had_slope_sub_clipped$sst), 3)` °C per decade) and **B**) significance of rate of SST change. Grey ocean area was not included in these analyses.

---

<br/>


### Figure S9

```{r MHW frequency by ecoregion}

## Modelling per ecoregion
pixel_frequency_eco <- lme4::lmList(total_events ~ year | ecoregion, data = mhw_pixel %>% filter(!is.na(total_events)))
#summary(pixel_frequency_eco)

plot_freq_region <- ggplot(frequency_df, aes(x=year, y=total_events)) + 
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), strip.background = element_blank(), axis.title.x=element_blank(), axis.text.x=element_blank()) +
  #geom_point(colour = "grey", alpha = 0.15, position = position_jitter()) +
  stat_summary(fun="mean", geom= "point", size = 1) +
  stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), geom="errorbar", width=0) +
  geom_smooth(method = "glm", se= TRUE, method.args = list(family= "poisson"), colour = "steelblue") +
  expand_limits(x = c(1980, 2020)) +
  labs(x="Year", y="Frequency")  +
  facet_wrap(~ecoregion, nrow = 1)


```

```{r MHW duration by ecoregion}

## Modelling per ecoregion
pixel_duration_eco <- lme4::lmList(log(avg_duration) ~ year | ecoregion, data = mhw_pixel %>% filter(!is.na(avg_duration)))
#summary(pixel_duration_eco)

plot_dur_region <- ggplot(data = mhw_pixel, aes(x = year, y = avg_duration)) + 
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.x=element_blank(), axis.text.x=element_blank()) +
  #geom_point(colour = "grey", alpha = 0.15, position = position_jitter()) +
  stat_summary(fun="mean", geom= "point", size = 1) +
  stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), geom="errorbar", width=0) +
  geom_smooth(method = "glm", se= TRUE, method.args = list(family= "poisson"), colour = "steelblue") +
  expand_limits(x = c(1980, 2020)) +
  labs(x="Year", y="Duration (days)")  +
  facet_wrap(~ecoregion, nrow = 1)

```

```{r MHW return time by ecoregion}

## Modelling per ecoregion
pixel_rt_eco <- lme4::lmList(log(avg_rt) ~ year | ecoregion, data = mhw_pixel %>% filter(!is.na(avg_rt)))
#summary(pixel_rt_eco)

plot_rt_region <- ggplot(data = mhw_pixel, aes(x = year, y = avg_rt)) + 
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.x=element_blank(), axis.text.x=element_blank()) +
  #geom_point(colour = "grey", alpha = 0.15, position = position_jitter()) +
  stat_summary(fun="mean", geom= "point", size = 1) +
  stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), geom="errorbar", width=0) +
  geom_smooth(method = "glm", se= TRUE, method.args = list(family= "poisson"), colour = "steelblue") +
  expand_limits(x = c(1980, 2020)) +
  labs(x="Year", y="Return Time (days)")  +
  facet_wrap(~ecoregion, nrow = 1)

```

```{r MHW intensity by ecoregion}

## Modelling per ecoregion
pixel_maxint <- lme4::lmList(log(avg_maxint) ~ year | ecoregion, data=mhw_pixel %>% filter(!is.na(avg_maxint)))
#summary(pixel_maxint)

plot_int_region <- ggplot(data = mhw_pixel, aes(x = year, y = avg_maxint)) + 
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.x=element_blank(), axis.text.x=element_blank()) +
  #geom_point(colour = "grey", alpha = 0.15, position = position_jitter()) +
  stat_summary(fun="mean", geom= "point", size = 1) +
  stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), geom="errorbar", width=0) +
  geom_smooth(method = "lm", se= TRUE, colour = "steelblue") +
  expand_limits(x = c(1980, 2020)) +
  labs(x="Year", y=expression(Intensity~(degree~C)))  +
  facet_wrap(~ecoregion, nrow = 1)

```

```{r MHW onset rate by ecoregion}

## Modelling per ecoregion
pixel_onset <- lme4::lmList(log(avg_onset) ~ year | ecoregion, data=mhw_pixel %>% filter(!is.na(avg_onset)))
#summary(pixel_onset)

plot_onset_region <- ggplot(data = mhw_pixel, aes(x = year, y = avg_onset)) + 
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.x=element_blank(), axis.text.x=element_blank()) +
  #geom_point(colour = "grey", alpha = 0.15, position = position_jitter()) +
  stat_summary(fun="mean", geom= "point", size = 1) +
  stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), geom="errorbar", width=0) +
  geom_smooth(method = "lm", se= TRUE, colour = "steelblue") +
  expand_limits(x = c(1980, 2020)) +
  labs(x="Year", y = expression(Onset~rate~(degree~C/day)))  +
  facet_wrap(~ecoregion, nrow = 1)

```

```{r MHW total days by ecoregion}

## Modelling per ecoregion
pixel_days_eco <- lme4::lmList(total_MHW_days ~ year | ecoregion, family = poisson(link = "log"), data = mhw_pixel %>% filter(!is.na(total_MHW_days)))
#summary(pixel_days_eco)

plot_totalDays_region <- ggplot(data = mhw_pixel %>% filter(!is.na(total_MHW_days)), aes(x = year, y = total_MHW_days)) + 
  theme_bw() +
  theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), strip.background = element_blank(), strip.text.x = element_blank(), axis.text.x = element_text(angle = 90)) + 
  #geom_point(colour = "grey", alpha = 0.15, position = position_jitter()) +
  stat_summary(fun="mean", geom= "point", size = 1) +
  stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), geom="errorbar", width=0) +
  geom_smooth(method = "glm", se= TRUE, method.args = list(family= "poisson"), colour = "steelblue") +
  expand_limits(x = c(1980, 2020)) +
  labs(x="Year", y = "Total Days")  +
  facet_wrap(~ecoregion, nrow = 1)

```


```{r combine and save MHWs by ecoregion for Fig S9, fig.width = 12, fig.height = 10}

## Final combined MHW plot and save it
ggarrange(plot_freq_region, plot_dur_region, plot_rt_region, plot_int_region, plot_onset_region, plot_totalDays_region, ncol = 1, heights = c(0.85, 0.75, 0.75, 0.75, 0.75, 0.95))
  ggsave("figures/Supplemental/FigS9_MHW_ecoregion_metrics.pdf", width = 16, height = 12)
  ggsave("figures/Supplemental/FigS9_MHW_ecoregion_metrics.png", width = 16, height = 12)

```

**Supplemental Figure 9.** MHW trends (1981 - 2018) across Caribbean coral reefs by ecoregion. Temperature data are based on OISST gridded data to determine frequency (number events per year), duration (number days per event), return time (number days per event) since the previous event, onset rate (°C per day) from start until peak intensity, peak intensity (°C), and total days reefs experience MHWs per year. Points denote annual mean values (±SD) and blue lines represent linear (lm or glm) trends within each ecoregion (see **Figures 1, Supplemental Figure 5** for ecoregion locations). Frequency, duration, and return time across all Caribbean coral reefs are depicted in **Figure 5** in the main text. 

---

<br/>


## Tables {.tabset}

### <span style="color: #0072B2;">**Table 1**</span>

**Table 1.** Estimated warming rates from both HadISST and Pathfinder databases for different temporal ranges. Coral reef values are means of all 5,326 reef locations included in the study. The year 1994 was estimated as the beginning of the most recent period of warming across all Caribbean coral reefs (**see S1 Fig**). The HadISST data can be accessed at [www.metoffice.gov.uk/hadobs/hadisst/](www.metoffice.gov.uk/hadobs/hadisst/), the Pathfinder can be accessed at [www.ncei.noaa.gov/products/avhrr-pathfinder-sst](www.ncei.noaa.gov/products/avhrr-pathfinder-sst), and the OISST can be accessed at [www.ncei.noaa.gov/products/optimum-interpolation-sst](www.ncei.noaa.gov/products/optimum-interpolation-sst).

```{r HadISST warming rates for table}
#### Basin values
### Caribbean Basin (1871-2020)

## Rate of warming
had_basin_full_rate <- round(mean(had_slope_clipped$sst), 2)

## Total C
had_basin_full_value <- round(((had_basin_full_rate/10) * (2020-(1871-1))), 2) # multiply number of years by the yearly rate for total warming


### Caribbean Basin (1981-2020)

## Rate of warming
had_basin_sub_81_rate <- round(mean(had_slope_sub_clipped$sst), 2)

## Total C
had_basin_sub_81_value <- round(((had_basin_sub_81_rate/10) * (2020-(1981-1))), 2) # multiply number of years by the yearly rate for total warming


### Caribbean Basin (1994-2020)

## Clip HadISST slopes by MHW bounds
had_slope_sub_94 <- had_slope_sub_94[c(2,3,1)] # just reordering the dataframe
coordinates(had_slope_sub_94) <- c("x", "y") # transform lat/lon to SpatialPointsDataFrame
projection(had_slope_sub_94) <- proj # modify projection to match Pathfinder
had_94_slope_clipped <- had_slope_sub_94[bound_SP_df, ] # clip the Pathfinder SST slope by the new MHW bounds
had_slope_sub_94_clipped <- as.data.frame(had_94_slope_clipped) # convert to dataframe

## Rate of warming
had_basin_sub_94_rate <- round(mean(had_slope_sub_94_clipped$sst), 2)

## Total C
had_basin_sub_94_value <- round(((had_basin_sub_94_rate/10) * (2020-(1994-1))), 2) # multiply number of years by the yearly rate for total warming



#### Reef-specific values
### Caribbean Reefs (1871-2020)

## Rate of warming
had_sst <- had_gam_df %>% separate(date, c("year", "month","day"), convert = TRUE) # create year, month, and day column columns
had_reef_full_lm <- lm(sst ~ year, data = had_sst) # regression of temperature and year to calculate rate of warming
had_reef_full_rate <- round(had_reef_full_lm$coefficients[2]*10, 2) # extract the slope of rate and multiply it by 10 for decade rate

## Total C
had_reef_full_value <- round(((had_reef_full_rate/10) * (2020-(1871-1))), 2) # multiply number of years by the yearly rate for total warming


### Caribbean Reefs (1981-2020)

## Rate of warming
had_sst_sub_81 <- subset(had_sst, year >= 1981) # subset data for 1981-2020 only
had_reef_sub_81_lm <- lm(sst ~ year, data = had_sst_sub_81) # regression of temperature and year to calculate rate of warming (since 1981)
had_reef_sub_81_rate <- round(had_reef_sub_81_lm$coefficients[2]*10, 2) # extract the slope of rate and multiply it by 10 for decade rate

## Total C
had_reef_sub_81_value <- round(((had_reef_sub_81_rate/10) * (2020-(1981-1))), 2) # multiply number of years by the yearly rate for total warming


### Caribbean Reefs (1994-2020)

## Rate of warming
had_sst_sub_94 <- subset(had_sst, year >= 1994) # subset data for 1994-2020 only
had_reef_sub_94_lm <- lm(sst ~ year, data = had_sst_sub_94) # regression of temperature and year to calculate rate of warming (since 1994)
had_reef_sub_94_rate <- round(had_reef_sub_94_lm$coefficients[2]*10, 2) # extract the slope of rate and multiply it by 10 for decade rate

## Total C
had_reef_sub_94_value <- round(((had_reef_sub_94_rate/10) * (2020-(1994-1))), 2) # multiply number of years by the yearly rate for total warming

```

```{r Pathfinder warming rates for table}

#### Basin values
### Caribbean Basin (1981-2020)

## Rate of warming
path_basin_full_rate <- round(mean(path_slope_clipped$sst), 2)

## Total C
path_basin_full_value <- round(((path_basin_full_rate/10) * (2019-(1981-1))), 2) # multiply number of years by the yearly rate for total warming


#### Reef-specific values
### Caribbean Reefs (1981-2019)

## Rate of warming
path_sst <- path_gam_df # renaming the GAM dataframe for analyses below
path_reef_full_lm <- lm(sst ~ year, data = path_sst) # regression of temperature and year to calculate rate of warming
path_reef_full_rate <- round(path_reef_full_lm$coefficients[2]*10, 2) # extract the slope of rate and multiply it by 10 for decade rate

## Total C
path_reef_full_value <- round(((path_reef_full_rate/10) * (2019-(1981-1))), 2) # multiply number of years by the yearly rate for total warming


### Caribbean Reefs (1994-2019)

## Rate of warming
path_sst_sub <- subset(path_sst, year >= 1994) # subset data for 1994-2019 only
path_reef_sub_lm <- lm(sst ~ year, data = path_sst_sub) # regression of temperature and year to calculate rate of warming (since 1994)
path_reef_sub_rate <- round(path_reef_sub_lm$coefficients[2]*10, 2) # extract the slope of rate and multiply it by 10 for decade rate

## Total C
path_reef_sub_value <- round(((path_reef_sub_rate/10) * (2019-(1994-1))), 2) # multiply number of years by the yearly rate for total warming

```

```{r table 1 compilation and visualization}

## Compile dataframe from above calculated values/rates

table_1 <- data.frame("Temperature parameter" = c("Caribbean Basin (°C per decade)", "Caribbean Basin (total °C for period)", "Caribbean Reefs (°C per decade)", "Caribbean Reefs (total °C for period)", "Caribbean Basin (increasing frequency of MHW per year) "),
                      "HadISST (1871-2020)" = c(had_basin_full_rate, had_basin_full_value, had_reef_full_rate, had_reef_full_value, "NA"),
                      "HadISST (1981-2020)" = c(had_basin_sub_81_rate, had_basin_sub_81_value, had_reef_sub_81_rate, had_reef_sub_81_value, "NA"),
                      "HadISST (1994-2020)" = c(had_basin_sub_94_rate, had_basin_sub_94_value, had_reef_sub_94_rate, had_reef_sub_94_value, "NA"), 
                      "Pathfinder (1981-2019)" = c(path_basin_full_rate, path_basin_full_value, path_reef_full_rate, path_reef_full_value, "NA"),
                      "Pathfinder (1990-2019)" = c("NA", "NA", path_reef_sub_rate, path_reef_sub_value, "NA"),
                      "OISST" = c("NA", "NA", "NA", "NA", "0.05")
)


# View the completed 
kable(table_1, booktabs = TRUE, row.names = FALSE, col.names = c("Temperature parameter", "HadISST (1871-2020)", "HadISST (1981-2020)", "HadISST (1994-2020)", "Pathfinder (1981-2019)", "Pathfinder (1994-2019)", "OISST (1982-2019")) %>% 
  kable_styling(font_size = 11, full_width = FALSE)

```


### <span style="color: #0072B2;">**Table 2**</span>
**Table 2.** Published reports of global ocean surface warming rates. 

| Study | °C per decade | Years |
|:----|:----|:----|
| Casey and Cornillon 2001 ^41^ | 0.14 | 1960–1990 |
| Lawrence et al. 2004 ^87^ | 0.09–0.13 | 1985–2000 |
| Good et al. 2007 ^88^ | 0.17  | 1985–2004 |
| Burrows et al. 2011 ^89^ | 0.07 | 1960–2009 |
| USGCRP 2017 ^90^ | 0.15 | 1900–2016 |


### Table S1
**Table S1.** Marine heatwave (MHW) properties examined in this study, as developed by Hobday et al. 2016.

| Metric | Units | Description  |
|--------|:------------|:--------------------------------------------|
| Frequency | Number of events | Number of discrete MHW events |
| Total MHW days | days | The total number of days a location experienced a MHW per year |
| Duration | days | The number of days between the start and end date of each distinct MHW event |
| Peak intensity | °C | The maximum temperature, above the seasonal varying climatological mean, reached during the MHW event |  
| Onset rate | °C per day | The rate of change in temperature between the event start date and date of peak intensity |
| Return time | days | The number of days elapsed since a previous MHW event in that location |


### Table S2

**Supplemental Table 2.** Description of the SST or MHW metrics assessed in this manuscript with details on the source of the temperature data (database), the scale of the measure, any data transformations completed for statistical analyses (transformation), the statistical test performed, and the R package used for each test. Further details on these methods can be found on the corresponding GitHub repository [github.com/seabove7/CaribbeanSST](github.com/seabove7/CaribbeanSST) and on Zenodo (DOI: [10.5281/zenodo.4751658](10.5281/zenodo.4751658)).

| Metric | Database | Scale | Transformation | Statistical test	| Package (version) |
|:----|:----|:----|:----|:-------------|:----|
| Rate of SST change | HadISST |	basin |	NA |	GLS; correlation structure of time for autocorrelation |	nlme (3.1.151)^2^ |
| Rate of SST change |	HadISST |	reefs |	NA |	GAMM; cubic spline for year and cyclic cubic regression spline for month and correlation structure of time for autocorrelation |	mgcv (1.8.36)^3^ |
| Rate of SST change |	Pathfinder |	basin |	NA |	GLS; correlation structure of time for autocorrelation |	nlme (3.1.151)^2^ |
| MHW frequency |	OISST |	reefs |	NA |	GLM; poisson with log link |	stats (3.6.3)^4^ |
| MHW duration |	OISST |	reefs |	log |	OLS model |	stats (3.6.3)^4^ |
| MHW return time |	OISST |	reefs |	log |	OLS model |	stats (3.6.3)^4^ |
| MHW total # events |	OISST |	reefs by ecoregion |	NA	OLS model |	lme4 (1.1.27.1)^5^ |
| MHW duration |	OISST |	reefs by ecoregion |	log |	OLS model |	lme4 (1.1.27.1)^5^ |
| MHW return time |	OISST |	reefs by ecoregion |	log |	OLS model |	lme4 (1.1.27.1)^5^ |
| MHW max intensity |	OISST |	reefs by ecoregion |	log |	OLS model |	lme4 (1.1.27.1)^5^ |
| MHW onset |	OISST |	reefs by ecoregion |	log |	OLS model |	lme4 (1.1.27.1)^5^ |
| MHW frequency |	OISST |	reefs by ecoregion |	NA |	GLM; poisson with log link |	lme4 (1.1.27.1)^5^ |


### Table S3

**Supplemental Table 3.** Mean ocean warming rate (°C per decade; with 95% confidence interval) and total increase in temperature (°C) on coral reefs within each Caribbean ecoregion since the noted year of inflection point. The inflection point for each ecoregion was identified as the year in which annual warming rates significantly increased based on the first derivative of the GAM curve for each ecoregion (**see Figures 3 and S6**).

```{r Pathfinder ecoregion SST dataframe construction}

## Load the ecoregion extracted SST data (here using Rdata, but you can use csv if smaller)
eco_sst_path_df <- readRDS("data/Pathfinder/Pathfinder_ecoregion_sst.rds")
load("data/Pathfinder/Pathfinder_times.Rdata") # load the Pathfinder R data containing 'times'

dates <- data.frame(date = paste("X", rep(1:460, 1), sep = ""),
                    date3 = time,
                    date2 = time)



# Rename "Northern GoM" and "Northern GoM" to just GoM (these will be considered the same ecoregion from here on)
eco_sst_path_df$ecoregion <- gsub("Northern G", "G", eco_sst_path_df$ecoregion)
eco_sst_path_df$ecoregion <- gsub("Southern G", "G", eco_sst_path_df$ecoregion)

eco_sst_path_df <- left_join(eco_sst_path_df, dates, by = c("date" = "date")) # left-join dataframes by date
eco_sst_path_df <- eco_sst_path_df %>% separate(date2, c("year", "month", "day"), convert = TRUE) # create year, month, and day column columns
eco_sst_path_df$month2 <- factor(eco_sst_path_df$month) # make a month as a factor column for plotting  

```

```{r Pathfinder extract warming rate from ecoregions}

region_names <- levels(factor(eco_sst_path_df$ecoregion)) # pull list of the different ecoregions

# make a dataframe of ecoregion and the year of warming increase
ecoregion_warm_year <- eco_gam_slope %>% # this is the dataframe from the GAM per ecoregion section
  filter(year >= 1981) %>% # filter for data since 1981 to match Pathfinder timeframe
  group_by(ecoregion) %>% # get a value by ecoregion
  slice(which.min(value)) %>% # pull the minimum value of SST (this will be the first year of the increase)
  select(ecoregion, year) %>% # select for just the ecoregion and year of warming
  rename(warm_year = year)


# join the warming year to the SST dataframe
eco_sst_path_df <- eco_sst_path_df %>% 
  left_join(ecoregion_warm_year, by = c("ecoregion" = "ecoregion"))

# create a dataframe to fill in the forloop
ecoregion_slope <- data.frame(ecoregion = character(),
                              warm_year = numeric(),
                              slope = numeric(),
                              lw_CI = numeric(),
                              up_CI = numeric())

# forloop that will calculate linear rate of warming per region along with confidence intervals
for (r in 1:length(region_names)) {
  
  region <- region_names[r]
  warm_yr <- ecoregion_warm_year[[r, 2]]
  
  ecoregion_subset <- eco_sst_path_df %>% 
    filter(ecoregion == region & year >= warm_yr)
  
  ecoregion_lm <- lm(sst ~ year, data = ecoregion_subset) # perform regression of sst through time
  slope <- round(ecoregion_lm[["coefficients"]][["year"]], 3) # extract the slope of SST over time
  lw_CI <- round(confint(ecoregion_lm, level = 0.95)[2,1], 4) # extract the lower CI 
  up_CI <- round(confint(ecoregion_lm, level = 0.95)[2,2], 4) # extract the upper CI 
  
  # add data to dataframe and convert rates to per decade 
  slope_df <- data.frame(ecoregion = region,
                         warm_year = warm_yr,
                         slope = (slope * 10),
                         lw_CI = (lw_CI * 10),
                         up_CI = (up_CI * 10))
  
  ecoregion_slope <- rbind(ecoregion_slope, slope_df) # add to the existing dataframe
}

# calculate the total amount warmed per ecoregion
ecoregion_slope$total_warm <- round(((ecoregion_slope$slope / 10) * (2019 - ecoregion_slope$warm_year)), 2)

```

```{r table S3 visualization}

## Compile dataframe from ecoregion rates
kable(ecoregion_slope, booktabs = TRUE, row.names = FALSE, col.names = c("Ecoregion", "Inflection point", "Mean rate (°C per decade)", "Lower confidence interval", "Upper confidence interval", "Warming extent (°C)")) %>% 
  kable_styling(font_size = 12, full_width = FALSE)

```

### Table S4

**Table S4.** Model results for MHW trends on coral reefs in the Caribbean basin between 1981-2018. Frequency was modeled using a glm model with poisson distribution and log link. Estimates, standard error, z scores (statistic), and p-values are reported. Nagelkerke pseudo r-squared used to assess goodness of fit. MHW duration and return time were log transformed before modeling with ols models. Estimate, standard error, t value (statistic) and p-value are reported along with multiple and adjusted r-squared.

```{r table S4 saving}

## Make summary table of main text MHW models:
# make a list containing R2 value per model
freq_r2_vec <- c("R2", round(freq_r2, 4), "", "", "")
dur_r2_vec <- c("R2", round(dur_r2, 4), "", "", "")
rt_r2_vec <- c("R2", round(rt_r2, 4), "", "", "")

# combine model output and R2 per metric
mhw_mod_out <- rbind(freq_mod, freq_r2_vec, dur_mod, dur_r2_vec, rt_mod, rt_r2_vec)

mhw_mod_out <- mhw_mod_out %>% 
  mutate(estimate = round(as.numeric(estimate), 3),
         std.error = round(as.numeric(std.error), 3),
         statistic = round(as.numeric(statistic), 3),
         p.value = gsub("0", "< 0.001", p.value)) %>% 
  rename(" " = term,
        "Estimate" = estimate,
        "Standard error" = std.error,
        "Statistic" = statistic,
        "P-value" = p.value)
  

# combine them with format
table_s4 <- kable(mhw_mod_out, booktabs = T) %>%
  kable_styling(font_size = 12, full_width = F) %>% 
  pack_rows("Frequency", 1, 3) %>%
  pack_rows("Duration", 4, 6) %>%
  pack_rows("Return Time", 7, 9)
table_s4

```


### Table S4

**Table S5.** Mean decadal value of MHW parameters (frequency, duration, and return time) for the entire basin and by ecoregion.

```{r MHW decade values}

### Decade summaries across Caribbean
# Mean frequency:
freq_decade_summary <- mhw_pixel %>% 
  group_by(year, total_events) %>% 
  mutate(decade = floor(as.numeric(year) / 10) * 10) %>% 
  group_by(decade) %>% 
  summarise(frequency = mean(total_events, na.rm = TRUE))

# Mean duration:
duration_decade_summary <- mhw_pixel %>% 
  group_by(year, avg_duration) %>% 
  mutate(decade = floor(as.numeric(year) / 10) * 10) %>% 
  group_by(decade) %>% 
  summarise(duration = mean(avg_duration, na.rm = TRUE))

# Mean return time:
rt_decade_summary <- mhw_pixel %>% 
  group_by(year, avg_rt) %>% 
  mutate(decade = floor(as.numeric(year) / 10) * 10) %>% 
  group_by(decade) %>% 
  summarise("return time" = mean(avg_rt, na.rm = TRUE))


### Decade summaries by ecoregion
# Mean frequency:
freq_decade_eco_summary <- mhw_pixel %>% 
  group_by(year, ecoregion, total_events) %>% 
  mutate(decade = floor(as.numeric(year) / 10) * 10) %>% 
  group_by(decade, ecoregion) %>% 
  summarise(frequency = mean(total_events, na.rm = TRUE))

# Mean duration:
duration_decade_eco_summary <- mhw_pixel %>% 
  group_by(year, ecoregion, avg_duration) %>% 
  mutate(decade = floor(as.numeric(year) / 10) * 10) %>% 
  group_by(decade, ecoregion) %>% 
  summarise(duration = mean(avg_duration, na.rm = TRUE))

# Mean return time:
rt_decade_eco_summary <- mhw_pixel %>% 
  group_by(year, ecoregion, avg_rt) %>% 
  mutate(decade = floor(as.numeric(year) / 10) * 10) %>% 
  group_by(decade, ecoregion) %>% 
  summarise("return time" = mean(avg_rt, na.rm = TRUE))

```

```{r table S5 - MHW decade summaries}

# Frequency data per region (and across entire Caribbean)
freq_decade_full <- freq_decade_summary %>% 
  add_column(ecoregion = rep("Caribbean", nrow(freq_decade_summary)), .before = "frequency") %>% 
  bind_rows(freq_decade_eco_summary) %>% 
  add_column(metric = rep("Frequency", 36), .before = "ecoregion") %>%  
  mutate(frequency = round(frequency, 1)) %>% 
  spread(decade, frequency)

# Duration data per region (and across entire Caribbean)
dur_decade_full <- duration_decade_summary %>% 
  add_column(ecoregion = rep("Caribbean", nrow(duration_decade_summary)), .before = "duration") %>% 
  bind_rows(duration_decade_eco_summary) %>% 
  add_column(metric = rep("Duration", 36), .before = "ecoregion") %>%    
  mutate(duration = round(duration, 1)) %>%   
  spread(decade, duration)

# Return time data per region (and across entire Caribbean)
rt_decade_full <- rt_decade_summary %>% 
  add_column(ecoregion = rep("Caribbean", nrow(rt_decade_summary)), .before = "return time") %>% 
  bind_rows(rt_decade_eco_summary) %>% 
  add_column(metric = rep("Return time", 36), .before = "ecoregion") %>%  
  mutate(`return time` = round(`return time`, 1)) %>%
  spread(decade, `return time`)


# Combine all parameters into single table
mhw_decade_full <- freq_decade_full %>% 
  bind_rows(dur_decade_full, rt_decade_full) %>% 
  mutate(ecoregion = factor(ecoregion, levels = c("Caribbean", "Bahamian", "Eastern Caribbean", "Floridian", "Greater Antilles", "Gulf of Mexico", "Southern Caribbean", "Southwestern Caribbean", "Western Caribbean"))) %>% 
  rename(Region = ecoregion) %>% 
  arrange(metric, Region)


## Create table with format for markdown and to save
table_s5 <- kable(mhw_decade_full[-1], booktabs = T) %>%
  kable_styling(font_size = 12, full_width = F) %>% 
  row_spec(c(1, 10, 19), bold = TRUE) %>% 
  pack_rows("Duration (days)", 1, 9) %>% 
  pack_rows("Frequency (events per year)", 10, 18) %>%  
  pack_rows("Return Time (days)", 19, 27)  
table_s5

```


```{r export data tables to excel WB}

### Create workbook
wb <- createWorkbook()

# add 'Table 1' worksheet
addWorksheet(wb, "Table 1 - Caribbean warming") 
writeData(wb, sheet = 1, x = table_1)
setColWidths(wb, sheet = 1, cols = 1:6, widths = "auto")

# add 'Table S3' worksheet
addWorksheet(wb, "Table S3 - Ecoregion warming") 
writeData(wb, sheet = 2, x = ecoregion_slope)
setColWidths(wb, sheet = 2, cols = 1:6, widths = "auto")

# add 'Table S4' worksheet
addWorksheet(wb, "Table S4 - MHW model output") 
writeData(wb, sheet = 3, x = mhw_mod_out)
setColWidths(wb, sheet = 3, cols = 1:5, widths = "auto")

## add 'Table S5' worksheet
addWorksheet(wb, "Table S5 - MHW metrics") 
writeData(wb, sheet = 4, x = mhw_decade_full)
setColWidths(wb, sheet = 4, cols = 1:5, widths = "auto")

# save workbook
saveWorkbook(wb, file="data/Supplemental_Tables.xlsx", overwrite = TRUE)

```


## Session information {.tabset}

Sea surface temperature code written by [Colleen B. Bove](https://colleenbove.science) and marine heatwave code written by [Laura Mudge](https://lmudge13.github.io/index.html).

Session information from the latest compile on `r date`:

```{r session info}

sessionInfo()

```
